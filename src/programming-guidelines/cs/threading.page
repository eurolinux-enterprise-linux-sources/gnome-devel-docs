<?xml version="1.0" encoding="utf-8"?>
<page xmlns="http://projectmallard.org/1.0/" xmlns:its="http://www.w3.org/2005/11/its" xmlns:xi="http://www.w3.org/2003/XInclude" type="topic" id="threading" xml:lang="cs">

  <info>
    <link type="guide" xref="index#specific-how-tos"/>

    <credit type="author copyright">
      <name>Philip Withnall</name>
      <email its:translate="no">philip.withnall@collabora.co.uk</email>
      <years>2015</years>
    </credit>

    <include xmlns="http://www.w3.org/2001/XInclude" href="cc-by-sa-3-0.xml"/>

    <desc>Přesun výpočtů mimo hlavní vlákno do pracovních vláken</desc>
  </info>

  <title>Vlákna</title>

  <synopsis>
    <title>Shrnutí</title>

    <list>
      <item><p>Pokud je to možné, vlákna nepoužívejte (<link xref="#when-to-use-threading"/>)</p></item>
      <item><p>Pokud vlákna použít musíte, použijte <code>GTask</code> nebo <code>GThreadPool</code> a kód vlákna izolujte co nejvíce je možné. (<link xref="#using-threading"/>)</p></item>
      <item><p>Při ručním požití <code>GThread</code> používejte <code>g_thread_join()</code>, abyste předešli únikům prostředků vlákna. (<link xref="#using-threading"/>)</p></item>
      <item><p>Při použití vláken dávejte pozor, jaký kód spouštíte v <code>GMainContext</code>. Spuštění kódu v nesprávném kontextu může způsobit souběh podmínek nebo blokování hlavní smyčky. (<link xref="#using-threading"/>)</p></item>
    </list>
  </synopsis>

  <section id="when-to-use-threading">
    <title>Kdy použít vlákna</title>

    <p>Když píšete projekty s pomocí GLib, mělo by být výchozím přístupem pravidlo <em style="strong">nikdy nepoužívat vlákna</em>. Místo toho správně používejte <link xref="main-contexts">hlavní kontext GLib</link>, který, skrz použití asynchronních operací, umožňuje většině blokujících V/V operací pokračovat na pozadí, zatímco hlavní kontext pokračuje ve zpracování dalších událostí. Analýza, kontrola a ladění programového kódu vláken se velmi rychle dokáže zvrhnout ve velmi složitou věc.</p>

    <p>Vlákna by se měla používat jen, když je to nutné kvůli externí knihovně, která má blokující funkce, které potřebujete volat z kódu GLib. Jestliže knihovna poskytuje neblokující variantu, nebo nějakou integrovanou se smyčkou <link href="http://pubs.opengroup.org/onlinepubs/009695399/functions/poll.html"><code>poll()</code></link>, měli byste takové variantě dát přednost. Pokud musíte opravdu použít blokující funkci, měli byste k ní napsat tenký obalující kód, který ji převede na běžnou asynchronní funkci ve <link href="https://developer.gnome.org/gio/stable/GAsyncResult.html">stylu <code>GAsyncResult</code></link> z GLib, a který spustí blokující operaci v pracovním vlákně.</p>

    <example>
      <p>Například:</p>
      <code mime="text/x-csrc">
int
some_blocking_function (void *param1,
                        void *param2);
</code>
      <p>By měla být obalena jako:</p>
      <code mime="text/x-csrc">
void
some_blocking_function_async (void                 *param1,
                              void                 *param2,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data);
int
some_blocking_function_finish (GAsyncResult        *result,
                               GError             **error);
</code>

      <p>S nějakou takovouto implementací:</p>
      <code mime="text/x-csrc">/* Zapouzdření pro parametry volání */
typedef struct {
  void *param1;
  void *param2;
} SomeBlockingFunctionData;

static void
some_blocking_function_data_free (SomeBlockingFunctionData *data)
{
  free_param (data-&gt;param1);
  free_param (data-&gt;param2);

  g_free (data);
}

static void
some_blocking_function_thread_cb (GTask         *task,
                                  gpointer       source_object,
                                  gpointer       task_data,
                                  GCancellable  *cancellable)
{
  SomeBlockingFunctionData *data = task_data;
  int retval;

  /* Obsluha zrušení */
  if (g_task_return_error_if_cancelled (task))
    {
      return;
    }

  /* Spuštění blokující funkce */
  retval = some_blocking_function (data-&gt;param1, data-&gt;param2);
  g_task_return_int (task, retval);
}

void
some_blocking_function_async (void                 *param1,
                              void                 *param2,
                              GCancellable         *cancellable,
                              GAsyncReadyCallback   callback,
                              gpointer              user_data)
{
  GTask *task = NULL;  /* vlastněno */
  SomeBlockingFunctionData *data = NULL;  /* vlastněno */

  g_return_if_fail (validate_param (param1));
  g_return_if_fail (validate_param (param2));
  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));

  task = g_task_new (NULL, cancellable, callback, user_data);
  g_task_set_source_tag (task, some_blocking_function_async);

  /* Zrušení by mělo být obslouženo ručně pomocí mechanizmu určeného
   * konkrétně pro some_blocking_function(). */
  g_task_set_return_on_cancel (task, FALSE);

  /* Nastaví zapouzdření obsahující parametry volání. Zkopíruje je, aby se
   * předešlo problémům se zamykáním mezi volajícím vláknem a pracovním vláknem */
  data = g_new0 (SomeBlockingFunctionData, 1);
  data-&gt;param1 = copy_param (param1);
  data-&gt;param2 = copy_param (param2);

  g_task_set_task_data (task, data, some_blocking_function_data_free);

  /* Spustí úlohu v pracovním vlákně a ihned se vrátí, zatímco zpracování
   * pokračuje na pozadí. Když je dokončeno, je zavolána funkce @callback
   * ve výchozím hlavním kontextu aktuálního vlákna */
  g_task_run_in_thread (task, some_blocking_function_thread_cb);

  g_object_unref (task);
}

int
some_blocking_function_finish (GAsyncResult  *result,
                               GError       **error)
{
  g_return_val_if_fail (g_task_is_valid (result,
                                         some_blocking_function_async), -1);
  g_return_val_if_fail (error == NULL || *error == NULL, -1);

  return g_task_propagate_int (G_TASK (result), error);
}</code>
      <p>Další podrobnosti viz <link href="https://developer.gnome.org/gio/stable/GAsyncResult.html">dokumentace k <code>GAsyncResult</code></link>. Jednoduchým způsobem, jak implementovat pracovní vlákno, je <link href="https://developer.gnome.org/gio/stable/GTask.html"><code>GTask</code></link> a <link href="https://developer.gnome.org/gio/stable/GTask.html#g-task-run-in-thread"><code>g_task_run_in_thread()</code></link>. (Viz také <link xref="main-contexts#gtask"/>.)</p>
    </example>
  </section>

  <section id="using-threading">
    <title>Používání vláken</title>

    <p>Pokud není pro napsání pracovního vlákna použitelný <code>GTask</code>, musí být použit přístup na nižší úrovni. To ale hodně dobře zvažte, protože je velmi snadné napsat kód vlákna nesprávným způsobem, který způsobí za běhu nepředvidatelné chyby, nekonečné zámky nebo spotřebu přílišného množství prostředků a ukončení programu.</p>

    <p>Kompletní návod pro psaní vláken je mimo rozsah tohoto dokumentu, ale existuje řada dalších příruček, podle kterých se můžete řídit, abyste omezili vznik potenciálních chyb v kódu vlákna. Obecným principem je omezit množství kódu a dat, které budou vláknem ovlivněny. Například omezením počtu vláken, složitosti implementace pracovního vlákna a množství dat sdílených mezi vlákny.</p>

    <list>
      <item>
        <p>Pokud je to možné, použijte místo ručního vytváření svých <link href="https://developer.gnome.org/glib/stable/glib-Threads.html"><code>GThread</code></link> třídu <link href="https://developer.gnome.org/glib/stable/glib-Thread-Pools.html"><code>GThreadPool</code></link>. <code>GThreadPool</code> podporuje pracovní fronty, omezení počtu spuštěných vláken a automatické sloučení dokončených vláken, takže nedochází k jejich úniku.</p>
      </item>
      <item>
        <p>Kdy není možné použít <code>GThreadPool</code> (což je zřídkavý případ):</p>

        <list>
          <item>
            <p>Použijte ke spuštění vlákna <link href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-try-new"><code>g_thread_try_new()</code></link> namísto <link href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-new"><code>g_thread_new()</code></link>, a chyby způsobené vybočením z vlákna pak můžete skvěle ošetřit, místo aby došlo k nepodmíněnému přerušení programu.</p>
          </item>
          <item>
            <p>Výslovně spojte vlákna pomocí <link href="https://developer.gnome.org/glib/stable/glib-Threads.html#g-thread-join"><code>g_thread_join()</code></link>, abyste předešli úniku prostředků vlákna.</p>
          </item>
        </list>
      </item>
      <item>
        <p>Místo ručního zamykání pomocí mutexů použijte raději předávání zpráv do dat přenášených mezi vlákny. <code>GThreadPool</code> to vyloženě podporuje pomocí <link href="https://developer.gnome.org/glib/stable/glib-Thread-Pools.html#g-thread-pool-push"><code>g_thread_pool_push()</code></link>.</p>
      </item>
      <item>
        <p>Když se musí použít mutexy:</p>

        <list>
          <item>
            <p>Programový kód vlákna izolujte co nejvíce to jde, mutexy udržujte v rámci tříd privátní a pevně je spojte s velmi konkrétně zaměřenými členy třídy.</p>
          </item>
          <item>
            <p>U všech deklarací mutexů by měly být srozumitelné komentáře, ve kterých jsou uvedeny struktury nebo proměnné, k nimž chrání přístup. A obdobně by u oněch proměnných měl být komentář říkající, že by se k nim mělo přistupovat <em>pouze</em> pomocí mutexu, který je drží.</p>
          </item>
        </list>
      </item>
      <item>
        <p>Buďte opatrní s interakcemi mezi hlavním kontextem a vlákny. Například funkce <link href="https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html#g-timeout-add-seconds"><code>g_timeout_add_seconds()</code></link> přidává časovač, <em>který bude spuštěn v globálním výchozím hlavním kontextu</em>, který běží v hlavním vlákně, což <em>není nutně</em> aktuální vlákno. Když se to udělá špatně, může to znamenat, že to co bylo zamýšleno pro pracovní vlákno nešťastnou náhodou skončí spuštěné mimo v hlavním vlákně. (Viz také: <link xref="main-contexts#default-contexts"/>.)</p>
      </item>
    </list>
  </section>

  <section id="debugging">
    <title>Ladění</title>

    <p>Ladění vláken je poněkud zapeklité. Jednak protože se chyby těžko reprodukují a jednak protože je těžké odhalit jejich původ. To je jeden z hlavních důvodů, proč se vyhýbat vláknům a nevolit je jako první řešení.</p>

    <p>Při výskytu takovéto chyby však mohou být <link xref="tooling#helgrind-and-drd">užitečné nástroje drd a helgrind z Valgrind</link>.</p>
  </section>
</page>
