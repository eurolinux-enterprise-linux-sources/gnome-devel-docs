<?xml version="1.0" encoding="utf-8"?>
<page xmlns="http://projectmallard.org/1.0/" xmlns:its="http://www.w3.org/2005/11/its" xmlns:xi="http://www.w3.org/2001/XInclude" type="guide" style="task" id="textview.py" xml:lang="ko">
  <info>
    <title type="text">TextView (Python)</title>
    <link type="guide" xref="beginner.py#multiline"/>
    <link type="seealso" xref="strings.py"/>
    <link type="seealso" xref="scrolledwindow.py"/>
    <link type="next" xref="dialog.py"/>
    <revision version="0.2" date="2012-06-19" status="draft"/>

    <credit type="author copyright">
      <name>Sebastian Pölsterl</name>
      <email its:translate="no">sebp@k-d-w.org</email>
      <years>2011</years>
    </credit>

    <credit type="author copyright editor">
      <name>Marta Maria Casetti</name>
      <email its:translate="no">mmcasetti@gmail.com</email>
      <years>2012</years>
    </credit>

    <desc>GtkTextBuffer를 나타내는 위젯</desc>
  
    <mal:credit xmlns:mal="http://projectmallard.org/1.0/" type="translator copyright">
      <mal:name>조성호</mal:name>
      <mal:email>shcho@gnome.org</mal:email>
      <mal:years>2017</mal:years>
    </mal:credit>
  </info>

  <title>TextView</title>

  <note style="sidebar"><p>Gtk.TextView 예제입니다.</p>
  <p>"enter" 키를 누르면 줄이 바뀝니다.</p>
  <p>그러나 긴 문장을 쓸 경우 줄을 바꿀 수 있습니다(문장을 단어 단위로 나누어 줄을 바꿉니다).</p>
  <p>기이이이이이이이이이이이이이이이이이이인</p>
  <p>(길었다면)</p>
  <p>단어가 있다면, 수평 스크롤 표시줄이 나타납니다.</p></note>

  <media type="image" mime="image/png" src="media/textview.png"/>

  <links type="section"/>

  <section id="code">
  <title>예제 결과를 만드는 코드</title>

  <code mime="text/x-python" style="numbered">from gi.repository import Gtk
import sys


class MyWindow(Gtk.ApplicationWindow):

    def __init__(self, app):
        Gtk.Window.__init__(self, title="TextView Example", application=app)
        self.set_default_size(300, 450)

        # a scrollbar for the child widget (that is going to be the textview)
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_border_width(5)
        # we scroll only if needed
        scrolled_window.set_policy(
            Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        # a text buffer (stores text)
        buffer1 = Gtk.TextBuffer()

        # a textview (displays the buffer)
        textview = Gtk.TextView(buffer=buffer1)
        # wrap the text, if needed, breaking lines in between words
        textview.set_wrap_mode(Gtk.WrapMode.WORD)

        # textview is scrolled
        scrolled_window.add(textview)

        self.add(scrolled_window)


class MyApplication(Gtk.Application):

    def __init__(self):
        Gtk.Application.__init__(self)

    def do_activate(self):
        win = MyWindow(self)
        win.show_all()

    def do_startup(self):
        Gtk.Application.do_startup(self)

app = MyApplication()
exit_status = app.run(sys.argv)
sys.exit(exit_status)
</code>
  </section>

  <section id="methods">
  <title>TextView 위젯에 쓸만한 메서드</title>
  <p><code>Gtk.TextView</code>는 <code>Gtk.TextBuffer</code>에 저장한 텍스트를 나타냅니다. 그러나, 대부분 텍스트 처리는 텍스트 버퍼의 두 문자간 위치 <code>Gtk.TextIter</code>로 표현하는 반복자로 끝냅니다. 반복자는 항상 유효한 존재는 아닙니다. 버퍼의 내용에 영향을 주어 버퍼의 내용이 바뀌면 이 부분을 알고 있든 반복자는 무효화 처리됩니다. 이 때문에, 반복자는 버퍼를 수정할 때 위치 정보를 보관할 목적으로 사용할 수 없습니다. 위치 정보를 어딘가에 보관할 때 <code>visible(True)</code> 함수로 눈에 띄게 나타낼 수 있는 <code>Gtk.TextMark</code>를 사용합니다. 텍스트 버퍼에는 자체적으로 내장한 "insert" 마크(커서 위치)와 "selection_bound"마크가 있습니다.</p>
  <p>TextView 위젯의 메서드는 다음과 같습니다:</p>
  <list>
    <item><p>TextView 위젯은 기본적으로 편집할 수 있습니다. 편집할 수 없게 하려면  <code>set_editable(False)</code> 함수를 사용하십시오 버퍼에 편집할 수 있는 텍스트가 없다면, 마찬가지로 <code>set_cursor_visible(False)</code> 함수를 사용하시는것이 좋습니다.</p></item>
    <item><p>텍스트 정렬은 <code>set_justification(Gtk.Justification.JUSTIFICATION)</code> 함수로 설정합니다. 여기서 <code>JUSTIFICATION</code>은 <code>LEFT, RIGHT, CENTER, FILL</code> 값 중 하나가 들어갑니다.</p></item>
    <item><p>텍스트 줄 바꿈은 <code>set_wrap_mode(Gtk.WrapMode.WRAP)</code> 함수로 설정합니다. 여기서 <code>WRAP</code> 값은 <code>NONE</code> (텍스트 영역이 더 넓어짐), <code>CHAR</code> (커서가 나타날 수 있는 어디든 줄 바꿈), <code>WORD</code> (단어 사이 줄 바꿈), <code>WORD_CHAR</code> (단어 사이에 줄을 바꾸지만 문자를 더 넣을 여력이 안되면 문자 사이를 줄바꿈) 값 중 하나입니다.</p></item>
  </list>
  <p>TextBuffer 위젯의 메서드:</p>
  <list>
    <item><p><code>get_insert()</code> 함수에서는 삽입 지점 커서를 나타내는 <code>Gtk.TextMark</code>를 반환합니다.</p></item>
    <item><p><code>get_selection_bound()</code> 함수는 선택 범위를 나타내는 <code>Gtk.TextMark</code>를 반환합니다.</p></item>
    <item><p><code>length</code>에 양의 정수 또는 <code>-1</code>을 넣을 수 있는 <code>set_text("some text", length)</code> 함수는 <code>"some text"</code> 텍스트를 처음 <code>length</code> 글자 만큼 버퍼에 내용을 넣습니다. <code>length</code> 값을 생략하거나 <code>-1</code>로 두면, 텍스트를 전부 넣습니다. 어떤 값이 들어가면 버퍼의 내용을 해체합니다.</p></item>
    <item><p><code>iter</code> 에 텍스트 반복자가 들어가고 <code>length</code>에 양의 정수 또는 <code>-1</code>을 넣을 수 있는 <code>insert(iter, "some text", length)</code> 함수에는 <code>"some text"</code> 텍스트 중 처음 <code>length</code> 글자를 버퍼의 <code>iter</code> 위치에 삽입합니다. <code>length</code> 값을 생략하거나 <code>-1</code>로 두면, 텍스트를 전부 넣습니다.</p></item>
    <item><p><code>insert_at_cursor("some text", length)</code> 함수는 <code>insert(iter, "some text", length)</code> 함수와 동일한 동작을 취하지만 현재 커서 위치를 <code>iter</code>로 취합니다.</p></item>
    <item><p><code>iter</code>는 <code>Gtk.TextIter</code>이고, <code>left_gravity</code> 값은 부울린 값인 <code>create_mark("mark_name", iter, left_gravity)</code> 함수는 <code>Gtk.TextMark</code>를 <code>iter</code> 위치에 만듭니다. <code>"mark_name"</code>을 <code>None</code>으로 설정하면, 익명으로 표시합니다. 그렇지 않으면 <code>get_mark()</code> 함수를 활용할 때 지정 이름으로 표시 항목을 가져올 수 있습니다. 마크가 왼쪽 정렬 상태고 마크 현재 위치에 텍스트를 넣으면, 마크는 새로 넣은 텍스트의 왼편으로 갑니다. <code>left_gravity</code> 매개변수 값을 생략하면 기본값은 <code>False</code>로 들어갑니다.</p></item>
    <item><p>버퍼에 임의의 텍스트를 특정 형식으로 지정하려면, 형식 정보를 유지하는 태그를 지정해야하며, 다음과 같이  <code>create_tag("tag name", property)</code> 함수와 <code>apply_tag(tag, start_iter, end_iter)</code> 함수로 태그를 텍스트 영역에 적용해야합니다:</p>
      <code>
tag = textbuffer.create_tag("orange_bg", background="orange")
textbuffer.apply_tag(tag, start_iter, end_iter)</code>
     <p>다음은 텍스트에 적용하는 일반 모양새 일부입니다:</p>
      <list>
        <item><p>배경 색상("background" 속성)</p></item>
        <item><p>전경 색상("foreground" 속성)</p></item>
        <item><p>밑줄("underline" 속성)</p></item>
        <item><p>굵게("weight" 속성)</p></item>
        <item><p>기울임("style" 속성)</p></item>
        <item><p>취소선("strikethrough" 속성)</p></item>
        <item><p>양쪽배분("justification" 속성)</p></item>
        <item><p>크기("size"와 "size-points" 속성)</p></item>
        <item><p>텍스트 줄바꿈("wrap-mode" 속성)</p></item>
      </list>
    <p><code>remove_tag()</code> 함수로 태그 일부를 삭제하거나 <code>remove_all_tags()</code> 함수를 호출하여 주어진 영역의 모든 태그를 삭제할 수 있습니다.</p></item>
  </list>
  <p>TextIter 위젯 메서드</p>
  <list>
    <item><p><code>forward_search(needle, flags, limit)</code>는 <code>needle</code>을 앞방향으로 검색합니다. <code>Gtk.TextIter</code>에서 지정한 한계값에 도달하면 검색을 계속하지 않습니다. <code>flags</code> 는 <code>0</code>(결과 일치 내용이 정확해야함), <code>Gtk.TextSearchFlags.VISIBLE_ONLY</code> (보이지 않는 글자가 needle에 있을 수도 있음); <code>Gtk.TextSearchFlags.TEXT_ONLY</code> (일치 범위에 있는 내용에 픽셀 버퍼 또는 하위 위젯의 조합으로 이루어짐); <code>Gtk.TextSearchFlags.CASE_INSENSITIVE</code> (대소문자 관계 없이 일치하면 됨)값 중 하나로 지정하거나 비트-OR 연산자 <code>|</code>로 지정할 수 있습니다. 메서드에서는 시작 지점을 가리키는 <code>Gtk.TextIter</code>와 일치 결과를 찾은 지점 다음의 첫번째 문자를 튜플 형태로 반환합니다. 만약 일치 결과가 없으면 <code>None</code>을 반환합니다.</p></item>
    <item><p><code>backward_search(needle, flags, limit)</code> 함수는 <code>forward_search()</code>와 동일하게 동작하지만 뒷 방향으로 검색합니다.</p></item>
  </list>
  </section>

  <section id="references">
  <title>API 참고서</title>
  <p>이 예제는 다음 참고자료가 필요합니다:</p>
  <list>
    <item><p><link href="http://developer.gnome.org/gtk3/unstable/GtkTextView.html">GtkTextView</link></p></item>
    <item><p><link href="http://developer.gnome.org/gtk3/unstable/GtkTextBuffer.html">GtkTextBuffer</link></p></item>
    <item><p><link href="http://developer.gnome.org/gtk3/unstable/GtkTextTag.html">GtkTextTag</link></p></item>
    <item><p><link href="http://developer.gnome.org/gtk3/unstable/GtkScrolledWindow.html">GtkScrolledWindow</link></p></item>
    <item><p><link href="http://developer.gnome.org/gtk3/unstable/gtk3-Standard-Enumerations.html">표준 서수형 값 목록</link></p></item>
  </list>
  </section>
</page>
