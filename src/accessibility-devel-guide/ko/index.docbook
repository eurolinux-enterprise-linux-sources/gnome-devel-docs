<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
<!ENTITY gnomeversion "2.24">
<!ENTITY manrevision "2.24.0">
<!ENTITY date "September 2008">
<!ENTITY LEGAL SYSTEM "legal.xml">
<!ENTITY gad SYSTEM "gad.xml">
<!ENTITY gtest SYSTEM "gtest.xml">
]>
<?db.chunk.max_depth 4?>
<book id="index" lang="ko">
<title>그놈 접근성 개발자 안내서</title>
<bookinfo>
<abstract role="description">
<para>그놈 접근성 안내서는 다양한 사용자가 프로그램을 사용할 수 있도록 프로그래밍에 노력을 기울이고자 하는 개발자용 문서입니다. 이 안내서는 508가지 요구사항을 다루는 수많은 섹션으로 구성했습니다.</para>
</abstract>
<copyright><year>2008</year> <holder>Vincent Alexander</holder></copyright>
<copyright><year>2001, 2002</year> <holder>Calum Benson, Brian Cameron, Bill Haneman, Padraig O'Briain, Sharon Snider</holder></copyright>
<publisher role="maintainer"> 
<publishername>그놈 문서 프로젝트</publishername> 
</publisher>
<legalnotice id="legalnotice">
<para>전면 표지와 후면 표지, 그리고 바뀌지 않는 섹션을 제외한 이 문서의 복제, 배포, 수정은 자유 소프트웨어 재단이 발표한 1.1 버전 이후의 GNU 자유 문서 라이선스(GFDL) 조항에 따라 허용합니다. GFDL의 사본은 이 <ulink type="help" url="ghelp:fdl">링크</ulink>, 또는 설명서와 배포하는 COPYING-DOCS 파일에서 찾을 수 있습니다.</para>
<para>이 설명서는 GFDL에 따라 배포하는 그놈 설명서 모음의 일부입니다. 모음과는 별개로 이 설명서를 배포하고 싶다면, 라이선스 6장에 명시한대로 설명서에 라이선스 사본을 추가할 경우 가능합니다.</para>
<para>회사의 제품 및 서비스를 구분할 때 사용하는 여러 이름은 등록상표 입니다. 어떤 그놈 문서에 나타나는 등록상표 명칭이나 그놈 문서 프로젝트의 구성원의 이름이 있는 곳에는 대문자로 표기하거나 대문자 약자로 표기합니다.</para>
<para>DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT ARE PROVIDED UNDER THE TERMS OF THE GNU FREE DOCUMENTATION LICENSE WITH THE FURTHER UNDERSTANDING THAT: <orderedlist>
<listitem>
<para>DOCUMENT IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, WITHOUT LIMITATION, WARRANTIES THAT THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS FREE OF DEFECTS MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE OR NON-INFRINGING. THE ENTIRE RISK AS TO THE QUALITY, ACCURACY, AND PERFORMANCE OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS WITH YOU. SHOULD ANY DOCUMENT OR MODIFIED VERSION PROVE DEFECTIVE IN ANY RESPECT, YOU (NOT THE INITIAL WRITER, AUTHOR OR ANY CONTRIBUTOR) ASSUME THE COST OF ANY NECESSARY SERVICING, REPAIR OR CORRECTION. THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS LICENSE. NO USE OF ANY DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT IS AUTHORIZED HEREUNDER EXCEPT UNDER THIS DISCLAIMER; AND</para>
</listitem>
<listitem>
<para>UNDER NO CIRCUMSTANCES AND UNDER NO LEGAL THEORY, WHETHER IN TORT (INCLUDING NEGLIGENCE), CONTRACT, OR OTHERWISE, SHALL THE AUTHOR, INITIAL WRITER, ANY CONTRIBUTOR, OR ANY DISTRIBUTOR OF THE DOCUMENT OR MODIFIED VERSION OF THE DOCUMENT, OR ANY SUPPLIER OF ANY OF SUCH PARTIES, BE LIABLE TO ANY PERSON FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES OF ANY CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF GOODWILL, WORK STOPPAGE, COMPUTER FAILURE OR MALFUNCTION, OR ANY AND ALL OTHER DAMAGES OR LOSSES ARISING OUT OF OR RELATING TO USE OF THE DOCUMENT AND MODIFIED VERSIONS OF THE DOCUMENT, EVEN IF SUCH PARTY SHALL HAVE BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.</para>
</listitem>
</orderedlist></para>
</legalnotice>
 
<authorgroup> 
<author><firstname>Vincent</firstname> <surname>Alexander</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author>
<author><firstname>Calum</firstname> <surname>Benson</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author>
<author><firstname>Brian</firstname> <surname>Cameron</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author>
<author><firstname>Bill</firstname> <surname>Haneman</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author>
<author><firstname>Padraig</firstname> <surname>O'Briain</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author> 
<author><firstname>Sharon</firstname> <surname>Snider</surname> <affiliation> <orgname>그놈 문서 프로젝트</orgname> </affiliation></author>
</authorgroup>
<revhistory>
<revision><revnumber> 그놈 2.24 접근성 개발자 안내서 V2.24.0 </revnumber> <date>2008년 9월</date> <revdescription> 
<para role="author">그놈 문서 프로젝트</para> 
<para role="publisher">그놈 문서 프로젝트</para> 
</revdescription></revision>
<revision><revnumber> 그놈 2.24 접근성 개발자 안내서 V2.24.0 </revnumber> <date>2008년 9월</date> <revdescription> 
<para role="author">그놈 문서 프로젝트</para> 
<para role="publisher">그놈 문서 프로젝트</para> 
</revdescription></revision>
</revhistory>
<releaseinfo>이 설명서는 그놈 데스크톱 버전 2.24를 설명합니다.</releaseinfo>
<legalnotice> 
<title>피드백</title> 
<para>그놈 데스크톱과 이 설명서에 대한 버그 보고, 제안이 있다면, <ulink type="help" url="ghelp:user-guide?feedback">GNOME Feedback 페이지</ulink>를 참고하십시오.</para>
</legalnotice> 

    <othercredit class="translator">
      <personname>
        <firstname>조성호</firstname>
      </personname>
      <email>shcho@gnome.org</email>
    </othercredit>
    <copyright>
      
        <year>2016.</year>
      
      <holder>조성호</holder>
    </copyright>
  </bookinfo>
<chapter id="gad" status="draft">
<title>접근성이란 무엇입니까?</title>
<para>접근성이란 장애우가 실질적인 활동을 할 수 있게 돕는 수단을 말합니다.서비스, 제품, 정보 활용, 업무 활동이 해당합니다. 그놈은 장애우가 그놈 사용자 환경의 모든 기능을 활용할 수 있도록 라이브러리와 지원 프레임워크를 제공합니다.</para>
<para>필요한 경우 보조 기술(음성 인터페이스, 스크린 리더, 입력 장치 등)을 활용하여 일시/영구적인 장애를 지닌 사람이 그놈 데스크톱을 활용할 수 있습니다. 보조 기술은 야외 또는 직장에서 컴퓨터를 활용하는 사용자에게도 쓸만합니다. 예를 들어, 교통 체증 상황인 경우 음성 입출력을 활용하여 전자메일을 확인할 수 있습니다.</para>
<para>보조 기술은 그놈 저장소의 ATK 모듈에서 찾을 수 있는 접근성 도구 모음(ATK) API로 프로그램에서 정보를 받습니다. 그놈 위젯에 접근성 API 지원을 내장했기 때문에 그놈 프로그램은 별도의 작업 없이 보조 기술과 상당히 잘 동작해야합니다. 예를 들어, 보조 기술은 어쨌든 프로그램에(<function>gtk_label_set_text()</function> 함수 또는 <function>gtk_button_new_with_label()</function> 함수와 같은 GTK 함수 호출로)설정한 위젯 레이블을 자동으로 읽을 수 있습니다. 게다가 위젯과 관련한 풍선 도움말 텍스트가 있는지 찾아서 위젯의 기능을 사용자에게 설명할 때 활용합니다.</para>
<para>하지만 약간의 노력을 보태면, 보조 기술과 좀 더 잘 어우러진 프로그램 기능을 만들 수 있습니다. 개인 사용자를 돕는데 앞서, 이 안내서는 관공서, 교육 시장에 매우 매력적인 제품을 만들 수 있으며, 법적으로 접근성을 요구하는 수많은 프로그램도 만들 수 있습니다.</para>

<section>
<title>장애의 유형</title>
<para>미국만 보더라도, 약 3천만명 정도의 사람이 접근 불가능한 설계로 인하여 컴퓨터를 충분히 사용하지 못하고 있으며, 월드 와이드 웹을 사용하는 전세계 8%의 사람이 유사한 어려움을 겪고 있습니다. 장애 유형은 다음과 같습니다:</para>
<itemizedlist>
<listitem>
<para><emphasis>시각 장애</emphasis> - 시작 장에에는 저시력(근시, 난시, 초고도 근/원시, 색맹, 시야 협착 등)부터 완전한 맹인 단계까지가 여기에 해당합니다. 글자 크기 및 색상 선택, 손의 움직임 및 시선의 바람직한 연동성을 요구(마우스 커서 이동)하는 작업은 시각 장애우에게 불편을 초래합니다.</para>
</listitem>
<listitem>
<para><emphasis>운동 장애</emphasis> - 근육 제어에 이상이 있거나 힘이 약한 사용자는 표준 키보드나 마우스를 사용하는 것이 어렵습니다. 예를 들어, 두 키를 동시에 누를 수 없거나 임의의 키를 실수로 칠 수도 있습니다.</para>
</listitem>
<listitem>
<para><emphasis>청각 장애</emphasis> - 청각 장애는 일부 소리는 들을 수는 있지만 들은 단어나 문장을 구별하지 못하는 증상부터 심각한 난청 증상까지 포함합니다. 중요한 정보를 소리로만 다루는 프로그램은 이런 상요자에게 불편을 초래합니다.</para>
</listitem>
<listitem>
<para><emphasis>인지 및 언어 장애</emphasis> - 인지 및 언어 장애에는 난독증, 기억, 문제 해결과 이해, 언어 쓰거/말하기에 지장있는 경우가 이에 해당합니다. 복잡하거나 일관성이 없는 표시, 부적절한 단어의 선택으로 이러한 사용자가 컴퓨터 사용에 어려움을 겪습니다.</para>
</listitem>
<listitem>
<para><emphasis>발작 장애</emphasis> - 특정한 빛이나 반복적인 음성은 일부 민감한 사용자들에게 발작 증세를 일으킵니다.</para>
</listitem>
</itemizedlist>
</section>

<section id="gad-how-it-works">
<title>그놈의 접근성 동작 방식</title>
<para>접근성 도구 모음(ATK)은 GUI 구성 요소에 접근할 수 있도록 필요한 모든 인터페이스 구현체 모음을 기술했습니다. 인터페이스는 도구 모음과 무관합니다. 구현체는 GTK, Motif, Qt 등 다양한 위젯으로 작성할 수 있습니다.</para>
<para>GTK 위젯 구현체는 GTK 프로그램에서 실행 시간에 동적으로 불러올 수 있는 GAIL(그놈 접근성 구현체 라이브러리) 모듈에 있습니다. 한 번 불러오고 나면, 프로그램에서 표준 GTK 위젯을 활용하는 부분프로그램을 전체적으로 수정하지 않아도 기본적인 수준의 접근성을 확보합니다. GAIL을 불러오지 않으면 GTK 위젯에서 ATK API와의 일치 여부에 대한 핵심 정보를 전혀 돌려주지 않는 기본 접근성 구현체를 보유합니다. 부분적으로 처리 영역을 벗어나는 보노보 제어 기술을 활용하는 프로그램은 libgail-gnome모듈에서 접근성 지원 코드를 불러옵니다. 그놈 데스크톱 프로그램이 "/desktop/gnome/interface/accessibility" <application>gconf</application> 키 값에 따라 자동으로 이들 접근성 지원 라이브러리를 불러오느냐에 따라 "true" 부울린 값을 설정하면 보조 기술 지원을 활성화하며, gnome_program_init을 호출하는 프로그램이 런타임에서 적절한 접근성 라이브러리를 자동으로 불러옵니다. gtk+를 활용하지만 libgnome과 연동하지 않은 "순수 GTK+ 프로그램"의 경우 보조 기술 지원을 활성화하려면 GTK_MODULES 환경 변수에 "gail:atk-bridge" 값을 설정해야합니다.</para>
<para>다른 데스크톱에서 동작하는 대부분의 보조 기술은 역사적으로 데스크톱의 OS 이벤트 스누핑을 기반으로 동작하는 복잡한 오프스크린 모델, 비 지원 OS의 사용, 프로그램 기능 및 API, 기타 이식하기 난해한 기술의 관리가 필요함을 발견했습니다. 이 때문에 OS 및 프로그램별, 프로그램의 버전별로 각자 따로따로 놀아나는 "허접한" 보조기술 지원을 만들어냈습니다. 반면에 그놈 데스크톱에서는 AT에서 필요한 모든 정보를 프로그램이 실행할 때 그놈 접근성 프레임워크에서, 도구 모음과는 별개의 서비스 제공 인터페이스로 제공했습니다. SPI는 유닉스 기반 AT에 화면 리더, 화면 돋보기같은 수단을 제공하여 일관되고 안정적인 API로 실행중인 프로그램에 접근성 정보를 얻어냈고, 대부분에 경우에 있어 오프스크린 모델의 필요성을 불식시킬 수 있었습니다. 프로그램에 대한 접근성 지원은 도구 모음에 적절한 API에서 프로그램 도구 모음에 "내장"했고(대부분의 네이티브 C 프로그램에는 ATK를, 자바 프로그램에는 Java 접근성 API를 활용), 관련 "브릿지"(다이어그램 참고)로 "AT-SPI" 일반 인터페이스를 내놓았습니다.</para>
<figure id="gad-architecture">
<title>GNOME 접근성 구조</title>
<mediaobject><imageobject> <imagedata fileref="figures/GNOME_desktop_Accessibility.png" format="PNG"/> </imageobject> <textobject> <phrase>GNOME의 접근성 구조도</phrase> </textobject></mediaobject>
</figure>
<para>그놈의 내장 접근성 지원이란, 내장 지원 방식과 혼동되는 일반적이지 않은 수단은 활용하지 않도록 "자유로운" 보조 기술을 지원하는 보유 그놈 위젯을 활용하여 프로그램을 만듦을 의미합니다.</para>
<para>gtk+/GNOME 위젯은 이 문서 어디든 일반 접근성 지침을 따랐을 경우 접근할 수 있으며, 사용자 인터페이스의 역할에 맞는 ATK 인터페이스를 구현합니다. ATK 구현체는 그놈 도구 모음 위젯 "보유물"(오래되지 않은 gtk+ 및 그놈 위젯)로 제공하며, 대부분 기존 gtk+ 또는 그놈 위젯에서 오는 새 위젯도 적절한 접근성 지원을 물려받습니다.</para>
<para>그놈 내장 접근성 지원에서는 프로그램의 일부를 바꾸는 접근성 관련 코드 없이도 중요한 기능을 제공하지만, 보통 프로그램에서는 일부 위젯에 제공하는 기본 설명을 종종 개선할 수 있으며 프로그램에서 간단한 ATK 메서드 호출로 위젯의 개별 목적에 따라 다듬을 수 있습니다. 예를 들면, 대부분의 경우 프로그램에 적당한 ATK 함수 호출로 위젯의 글자 설명을 추가하거나 바꿔서 보조 기술의 결과물이 사용자에게 기능의 목적이나 상태를 설명할 수 있어야합니다. 자세한 내용은 <link linkend="gad-coding-guidelines">접근성 지원 코드 작성 지침서</link> 를 참고하십시오.</para>
<para>프로그램에 개별 제작 위젯을 사용한다면, 해당 위젯의 속성을 보조 기술에 알려주어야 합니다. 추가 정보는 <link linkend="gad-custom">개별 구성요소 접근성 처리</link> 및 <link linkend="gad-api-examples">접근성 API 활용 예제</link>를 참고하십시오.</para>
<para>추가로, GTK/GTK+에 관련된 심층 정보는 <ulink url="http://library.gnome.org/devel/gtk">GTK+ 참고 설명서</ulink>, <ulink url="http://live.gnome.org/GAP/AtkGuide/Gtk">ATK 안내서의 GTK 섹션</ulink>, GNOME에서 제공하는 <ulink url="http://library.gnome.org/devel/gtk-tutorial/stable/">GTK+ 2.0 활용 지침서</ulink>, 공식 문서인 <ulink url="http://library.gnome.org/devel/gtk-faq/stable/">GTK+ FAQ</ulink>을 참고하십시오.</para>
</section>

<section id="dev-start">
<title>개발자 간편 시작</title>
<para>시작할 때 몇가지 확인해볼 사항이 있습니다:</para>

<section id="dev-start-1">
<title>프로그램에 접근성이 있는지 어떻게 확인합니까?</title>
<para>시작하기에 앞서, <link linkend="gad-overview">GNOME 프로그램 접근성 처리 - 개요</link>를 참고하십시오. 코드 작성에 앞서 <link linkend="gad-ui-guidelines">접근성 지원 사용자 인터페이스 지침서</link>, <link linkend="gad-coding-guidelines">접근성 지원 코드 작성 지침서</link>를 참고하십시오. 설계 후 시험 항목에 대한 확인 목록을 참고하려면 <link linkend="gad-checklist">사용자 인터페이스 확인 목록</link>을 참고하십시오.</para>
</section>

<section id="dev-start-2">
<title>공통적인 함정에는 무엇이 있습니까?</title>
<para><link linkend="gad-checklist">사용자 인터페이스 확인 목록</link>에는 설계 단계에서 가끔씩 살펴볼 광범위한 분야를 다룹니다.</para>
</section>

<section id="dev-start-3">
<title>공통 ATK로 무얼 할 수 있습니까?</title>
<para>공통 ATK 호출 구성 요소의 약어 목록은 <link linkend="gad-api">여기</link>에 있습니다.</para>
</section>

<section id="dev-start-4">
<title>좀 더 복잡한 ATK로 무얼 할 수 있습니까?</title>
<para>추가 정보는 <link linkend="gad-custom">개별 요소 접근성 처리</link> 및 <link linkend="gad-api-examples">접근성 API 활용 예제</link> 를 살펴보십시오.</para>
</section>

<section id="dev-start-5">
<title>ATK, AT-SPI, GAIL, GTK+ 소개</title>
<screenshot>
<mediaobject><imageobject> <imagedata fileref="figures/gaa.jpg"/> </imageobject> <textobject> <phrase> 그놈 접근성 구조 </phrase> </textobject></mediaobject>
</screenshot>
<para>ATK는 추가 지원이 필요한 사용자의 컴퓨터에 접근성 추가 지원을 제공하는 그놈 도구 모음입니다. ATK는 스크린 리더, 돋보기, 대체 수단을 통해 데스크톱과 다양한 방식으로 상호 반응하는 입력 장치 같은 도구에서 활용합니다. 자세한 정보는 <ulink url="http://java-gnome.sourceforge.net/4.0/doc/api/org/gnome/atk/package-summary.html">ATK 소스포지 프로젝트</ulink> 및 <ulink url="http://library.gnome.org/devel/atk/stable/">ATK 라이브러리</ulink>를 참고하십시오.</para>
<para>AT-SPI는 프로그램을 실행하면서 요청하고 알림을 받는 보조 기술의 근본 서비스 인터페이스입니다. 완전한 API는 <ulink url="http://library.gnome.org/devel/at-spi-cspi/stable/">이 곳</ulink>에서 찾아볼 수 있습니다. 추가 자료는 <ulink url="http://accessibility.kde.org/developer/atk.php#coreclasses">KDE 접근성 개발 커뮤니티</ulink>에 있습니다.</para>
<para>GAIL(그놈 접근성 구현 라이브러리)은 ATK에서 정의한 접근성 인터페이스의 구현체입니다. GTK는 GAIL 모듈에서 ATK로 연동한 도구 모음입니다. 라이선스, 다운로드 구성 요소, 기타 정보는 <ulink url="http://www.t2-project.org/packages/gail.html">여기</ulink>에 있습니다. <ulink url="ftp://ftp.gnome.org/pub/GNOME/sources/gail/">GAIL 소스 코드</ulink>도 고급 ATK 사용법과 함께 최고의 활용 지침서로 제공합니다. 또한 이 안내서를 보는 여러분께서 아마도 <ulink url="http://library.gnome.org/devel/gail-libgail-util/stable/">GAIL 참고 설명서</ulink>에 관심이 있을지도 모르겠습니다.</para>
<para>GTK+는 그래픽 사용자 인터페이스를 만드는 라이브러리입니다. 유닉스 계열 플랫폼, 윈도우, 프레임버퍼 장치에서 동작합니다. GTK+는 클라이언트 프로그램의 유연한 라이선싱을 허용하는 GNU 라이브러리 일반 공중 사용 허가서(GNU LGPL)의 계약에 따라 출시했습니다. GTK+는 유연성을 극대화하는 C 기반 객체지향 구조를 지니고 있습니다. C++, Objective-C, Guile/Scheme, Perl, Python, TOM, Ada95, 자유 파스칼, Eiffel 등 다른 언어에 대한 바인딩도 있습니다.</para>
<para>또한 GTK/GTK+와 관련한 심층 정보는 <ulink url="http://library.gnome.org/devel/gtk">GTK+ 참고 설명서</ulink>, <ulink url="http://wiki.gnome.org/Accessibility/Documentation/GNOME2/AtkGuide/Gtk">ATK 안내서의 GTK 섹션</ulink>, 그놈에서 제공하는 <ulink url="http://library.gnome.org/devel/gtk-tutorial/stable/">GTK+ 2.0 활용 지침서</ulink>, 공식 <ulink url="http://library.gnome.org/devel/gtk-faq/stable/">GTK+ FAQ</ulink>를 참고하십시오.</para>
</section>
</section>

<section id="gad-overview">
<title>접근성 있는 GNOME 응용 프로그램 만들기 - 개요</title>
<para>프로그램에서 표준 GTK 위젯만 활용한다면, 프로그램에(확실히) 접근성 처리 과정에 별도로 해야 할 일이 없습니다. 다만, GUI 객체 중에 레이블이나 풍선 도움말이 없는 그래픽 단추, 상태 표시줄과 같은 구성 요소에 관련 있는 텍스트 설명이 없는 점에 주목하십시오.</para>
<para>일부 위젯에서 제공하는 기본 설명을 개선하고, 프로그램의 위젯별 목적에 맞춰 다듬을 수도 있습니다. 적당한 ATK 함수 호출로 위젯의 슬 설명을 추가하거나 바꾸어 보조 기술을 통해 사용자에게 위젯의 존재 목적과 상태를 설명할 수 있어야합니다. 자세한 내용은 <link linkend="gad-coding-guidelines">접근성 지원 코드 작성 지침서</link>를 참고하십시오.</para>
<para>프로그램에 개별 제작 위젯을 사용한다면, 해당 위젯의 속성을 보조 기술에 알려주어야 합니다. 추가 정보는 <link linkend="gad-custom">개별 구성요소 접근성 처리</link> 및 <link linkend="gad-api-examples">접근성 API 활용 예제</link>를 참고하십시오. Marc Mulcahy의 2002년 GUADEC 프리젠테이션 <ulink url="https://projects.gnome.org/accessibility/talks/GUAD3C/making-apps-accessible/start.html">"Making GNOME Applications Accessible"</ulink> 에서 자세한 내용을 살펴보실 수 있습니다.</para>
</section>

<section id="gad-coding-guidelines">
<title>접근성 지원 코드 작성 지침</title>
<para>가능한한 보조 기술이 프로그램에서 동작하도록 코드에서 처리할 수 있는 일을 여기에 언급하겠습니다. (이 문서 후반의 <link linkend="gad-ui-guidelines">접근성 지원 사용자 인터페이스 지침서</link>에서 GUI를 설계할 때 고려해야 할 사항을 찾아보실 수 있습니다):</para>
<itemizedlist>
<listitem>
<para>간단한 문장을 표시하지 않으려는 구성 요소(그래픽 단추의 경우)에 대해서는, <function>atk_object_set_name()</function> 함수로 이름을 지정하십시오. 이미지만 있는 단추, 논리 그룹을 붙일 패널, 텍스트 영역 등에 대해 이런 처리를 하고 싶을 수도 있습니다.</para>
</listitem>
<listitem>
<para>구성요소에 풍선 도움말을 제공할 수 없다면 사용자에게 제공할 수 있는 보조 기술의 설명을 제공하는 대신 <function>atk_object_set_description()</function> 함수를 사용하십시오. 예를 들자면, <guibutton>닫기</guibutton> 단추에 편의 설명을 제공하는 경우:</para>
<example>
<title>GtkButton에 편의 설명 제공</title>
<programlisting>
{
  AtkObject *obj;
  obj = gtk_widget_get_accessible(button);
  atk_object_set_description(obj,_("Closes the window"));
}
</programlisting>
</example>
</listitem>
<listitem>
<para>프로그램의 모든 이미지 및 아이콘에 글자 설명을 넣으려면 <function>atk_image_set_description()</function> 함수를 사용하십시오.</para>
</listitem>
<listitem>
<para>여러 구성 요소가 논리 그룹을 형성한다면 컨테이너 하나에 넣으십시오.</para>
</listitem>
<listitem>
<para>다른 구성 요소를 설명하는 레이블을 언제 넣든지, <function>atk_relation_set_add_relation()</function> 함수를 사용하여 어떤 레이블이 구성 요소에 붙었는지 보조 기술에서 확인할 수 있게 하십시오. (<function>gtk_label_set_mnemonic_widget()</function> 함수를 활용하여 구성요소의 레이블을 붙였다면 <constant>ATK_RELATION_LABEL_FOR</constant> 관계를 자동으로 만드므로 다음 코드는 필요하지 않습니다):</para>
<example>
<title>GtkWidget에 GtkLabel 연동</title>
<programlisting>
{
  GtkWidget *widget;
  GtkLabel *label;

  AtkObject *atk_widget, *atk_label;
  AtkRelationSet *relation_set;
  AtkRelation *relation;
  AtkObject *targets[1];

  atk_widget = gtk_widget_get_accessible(widget);
  atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

  relation_set = atk_object_ref_relation_set (atk_label);
  targets[0] = atk_widget;

  relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
  atk_relation_set_add(relation_set,relation);
  g_object_unref(G_OBJECT(relation));
}
</programlisting>
</example>
</listitem>
<listitem>
<para>개별 위젯을 만들 경우, 접근성을 지원하는지 확인하십시오. 다른 GTK 위젯의 파생요소인 개별 구성요소는 필요한 대로 접근성 정보를 물려받아야합니다. 추가 정보는 <link linkend="gad-custom">개별 구성요소 접근성 처리</link>를 살펴보십시오.</para>
</listitem>
<listitem>
<para>자유롭게 가져온 위젯을 깨먹지 마십시오! GUI에서 컨테이너에 접근할 수 없으면 컨테이너의 어떤 구성 요소에도 접근할 수 없습니다.</para>
</listitem>
</itemizedlist>
</section>

<section id="gad-api">
<title>접근성 API</title>
<para>보조 기술과 잘 동작하는지 프로그램에서 확인할 때 활용할 몇가지 기본 API 호출이 있습니다. 예를 들면 여러분이 직접 개별 편의 위젯을 작성할 수 있게 하는 그런 확장성을 지닌 완전한 접근성 API가 있습니다.</para>
<table frame="all">
<title>일반적으로 활용하는 ATK API 호출</title>
<tgroup cols="2" align="left">
<thead>
<row>
<entry>API</entry>
<entry>설명</entry>
</row>
</thead>
<tbody>
<row>
<entry>
<para><function>AtkObject* gtk_widget_get_accessible (GtkWidget*)</function></para>
</entry>
<entry>
<para>지정 GTK 위젯을 보조 기술로 설명하는 접근성 객체를 반환합니다.</para>
</entry>
</row>
<row>
<entry>
<para><function>void atk_object_set_name (AtkObject*, const gchar*)</function></para>
</entry>
<entry>
<para>접근성 객체의 이름을 지정합니다. 눌렀을 때 프로그램을 끝내는 그래픽 단추 객체가 있다면 해당 객체의 이름은 "끝내기"가 됩니다.</para>
</entry>
</row>
<row>
<entry>
<para><function>void atk_object_set_description (AtkObject*, const gchar*)</function></para>
</entry>
<entry>
<para>접근성 객체의 텍스트 설명을 설정합니다. 그래픽 "닫기" 단추 객체가 있다면 객체 설명은 "창을 닫습니다"가 됩니다.</para>
</entry>
</row>
<row>
<entry>
<para><function>AtkRelation* atk_relation_new (AtkObject**, gint, AtkRelationType)</function></para>
</entry>
<entry>
<para>대상 객체의 지정 키 밎 지정 목록의 새 관계를 만듭니다. 보통 어떤 위젯과 보조 기술의 관계가 어떻게 되는지를 나타냅니다. 예를 들어, 일부 GtkLabel 위젯은 동일한 창에 있는 GtkTreeView의 설명입니다.</para>
</entry>
</row>
<row>
<entry>
<para><function>void atk_image_set_description (AtkImage*, const gchar*)</function></para>
</entry>
<entry>
<para>접근 가능한 이미지 객체의 텍스트 설명을 설정합니다. 패널 애플릿에서 가상 데스크톱의 작은 미리보기 그림이 있다면, 이 그림에 대한 설명은 "1번 데스크톱에서 정리한 창을 보여주는 이미지"가 됩니다.</para>
</entry>
</row>
</tbody>
</tgroup>
</table>
</section>

<section id="gad-api-examples">
<title>접근성 API 활용 예제</title>
<para>앞서 설명한 대로, GTK 위젯을 설정했거나 ATK 인터페이스를 구현한 다른 위젯 라이브러리를 활용할 경우 프로그램에 접근할 수 있게 약간의 처리 과정을 거치든지 손을 댈 필요가 없습니다. 보통 손을 대야하는 대부분의 일반적인 경우는 두가지입니다:</para>
<itemizedlist>
<listitem>
<para><function>atk_object_set_description()</function>함수 또는 <function>atk_image_set_description():</function> 함수로 일부 컨트롤 및 이미지의 설명을 달아주십시오:</para>
<example>
<title>단추에서 볼 수 있는 설명 설정</title>
<programlisting>
{
   AtkObject *obj;
   obj = gtk_widget_get_accessible(button);
   atk_object_set_description(obj,_("Opens Preferences dialog"));
}
</programlisting>
</example>
<para>
</para>
</listitem>
<listitem>
<para><function>atk_relation_new()</function> 함수와 <function>atk_relation_set_add()</function> 함수로 위젯의 흔치 않은 그룹 관계를 지정하십시오:</para>
<example>
<title>두 컨트롤의 접근 관계 지정</title>
<programlisting>
{
  GtkWidget *widget;
  GtkLabel *label;

  AtkObject *atk_widget, *atk_label;
  AtkRelationSet *relation_set;
  AtkRelation *relation;
  AtkObject *targets[1];

  atk_widget = gtk_widget_get_accessible (widget);
  atk_label = gtk_widget_get_accessible (GTK_WIDGET(label));

  relation_set = atk_object_ref_relation_set (atk_label);
  targets[0] = atk_widget;

  relation = atk_relation_new(targets,1, ATK_RELATION_LABEL_FOR);
  atk_relation_set_add(relation_set,relation);
  g_object_unref(G_OBJECT(relation));
}
</programlisting>
</example>
</listitem>
</itemizedlist>
<para>이 섹션의 나머지 부분의 예제는 대부분 여러분이 ATK의 범위에서 흥미를 가질만한 내용을 다룹니다. 여러분이 개별 위젯(see <link linkend="gad-custom">개별 구성 요소 접근성 처리</link> 참고)을 작성할 경우 흥미를 가지거나 보조 기술 프로그램을 작성하고 싶겠지만 프로그램 개발자 입장에서 활용할 필요가 없는 기술도 다룹니다. 어떤 목적이든 <ulink url="ftp://ftp.gnome.org/pub/GNOME/sources/gail/">GAIL 소스 코드</ulink>는 고급 ATK 활용법을 다루는 최고의 사용 지침서로 제공합니다. GAIL은 GTK+로 통합했으며 더 이상 모듈 그 자체로는 없습니다.</para>

<section>
<title>gtk 모듈</title>
<para>GAIL(GTK 위젯 접근성 구현체 라이브러리)을 활용하는 프로그램은 GTK 모듈로 작성했습니다. GTK 모듈은 <varname>GTK_MODULES</varname> 환경 변수에서 모듈 라이브러리 이름을 지정했을 경우 프로그램 영역에 불러옵니다. 여러 모듈 라이브러리가 있다면 다음과 같이 콜론으로 구분하십시오:</para>
<para><userinput>setenv GTK_MODULES "libgail:libtestprops"</userinput></para>
<para>모든 GTK 모듈에는 <function>gtk_module_init()</function> 함수가 있습니다.</para>
</section>

<section>
<title>프로그램에서 접근성 정보 가져오기</title>
<para>ATK 호출을 활용하려는 프로그램은 다음 지시 사항 중 하나(또는 이상)를 진행해야합니다:</para>
<orderedlist>
<listitem>
<para><function>atk_add_focus_tracker()</function> 함수와 같은 이벤트 감시자를 만드십시오:</para>
<programlisting>atk_add_focus_tracker (_my_focus_tracker);</programlisting>
<para><function>_my_focus_tracker()</function>은 함수 프로토타입입니다:</para>
<programlisting>void _my_focus_tracker (AtkObject *aobject);</programlisting>
</listitem>
<listitem>
<para>atk_add_global_event_listener() 함수로 전역 이벤트 리스터를 설정하십시오:</para>
<programlisting>
mouse_watcher_focus_id =   atk_add_global_event_listener(_my_global_listener,"Gtk:GtkWidget:enter_notify_event");
</programlisting>
<para><function>_my_global_listener</function>에는 Glib <type>GSignalEmissionHook</type> 프로토타입을 지니고 있습니다. 이 예제에서는 <type>GtkWidget</type> 객체애서 enter_notify_even signal 시그널이 발생했을 때 <function>_my_global_listener()</function> 함수를 호출합니다.</para>
</listitem>
<listitem>
<para>다음 함수를 호출하여 ATK 최상위 객체에 접근하십시오.</para>
<programlisting>AtkObject *root_obj = atk_get_root();</programlisting>
<para>이 코드에서는 현재 실행중인 프로그램에서 모든 최상위 창 정보를 담은 <type>AtkObject</type>를 반환합니다. 사용자는 최상위 창에 해당하는 최상위 객체의 하위 객체로 접근하여 객체 계층을 타고 탐색할 수 있습니다.</para>
</listitem>
</orderedlist>
</section>

<section>
<title><type>AtkObject</type> 인터페이스 요청</title>
<para>(예: <function>gtk_widget_get_accessible()</function> 함수를 호출하여) 프로그램의 객체와 관련된 <type>AtkObject</type> 를 찾았다면, 다양한 방식으로 구현한 인터페이스를 찾을 수 있습니다:</para>
<orderedlist>
<listitem>
<para>예를 들자면 이미 존재하는 <function>ATK_IS_...</function> 매크로를 활용합니다:</para>
<itemizedlist>
<listitem>
<para><function>ATK_IS_ACTION(atkobj)</function></para>
</listitem>
<listitem>
<para><function>ATK_IS_COMPONENT(atkobj)</function></para>
</listitem>
<listitem>
<para>등(각 인터페이스당 하나를 활용)</para>
</listitem>
</itemizedlist>
<para>매크로에서 <function>TRUE</function>를 반환하면 인터페이스에서 안전하게 ATK 객체를 만들 수 있습니다.</para>
</listitem>
<listitem>
<para><function>atk_object_get_role()</function> 함수를 호출하여 <type>AtkObject</type> 동작을 시험하십시오. 어떤 주어진 동작이든 몇가지 ATK API를 구현합니다.</para>
</listitem>
</orderedlist>
</section>

<section>
<title>ATK 시그널 처리자 설정</title>
<para>예제에서는 <constant>column_inserted</constant> 시그널을 활용합니다:</para>
<programlisting>
table_column_inserted_id = g_signal_connect_closure_by_id (my_atk_obj, 
g_signal_lookup("column_inserted", G_OBJECT_TYPE(my_atk_obj)), 0, 
g_cclosure_new(G_CALLBACK (_my_table_column_inserted_func), NULL, NULL), FALSE);
</programlisting>
<para><type>AtkObject</type> <varname>my_atk_object</varname>에서 column_inserted 시그널이 나오면 <function>_my_table_column_inserted_func()</function> 함수를 호출합니다.</para>
<para>시그널에 세부 속성 값을 지원한다면 시그널에 연결하는 방식이 다를 수 있습니다. <constant>children_changed</constant> 시그널에는 <parameter>add</parameter> 세부 속성 값을 지원합니다. <parameter>add</parameter> 세부 속성값도 지정한 시그널에 연결하려면 다음 코드를 활용하십시오:</para>
<programlisting>
child_added_id = g_signal_connect_closure (my_atk_obj,"children_changed::add",
g_cclosure_new (G_CALLBACK(_my_children_changed_func), NULL, NULL), FALSE);
</programlisting>
<para>이 코드에서는 <type>AtkObject</type> <varname>my_atk_obj</varname>에서 나타난 <constant>children_changed</constant> 시그널에 <parameter>add</parameter> 세부 속성 값이 들어갔을 경우 <function>_my_children_changed_func()</function> 함수를 호출합니다.</para>
</section>

<section>
<title>ATK 객체 구현</title>
<para>GAIL(또는 다른 위젯 집합의 동일한 라이브러리)에 편의성 구현을 처리하지 않은 위젯을 활용한다면 ATK 객체를 구현해야합니다. GTK 모듈 처럼 구현해야 하는데, 그 이전에 <envar>GTK_MODULES</envar> 환경 변수를 설정하여 실행 시간에 불러오게 해야합니다.</para>

<section>
<title>등록</title>
<para>이 예제에서는 GTK_TYPE_MYTYPE 객체 활용을 예로 들어보겠습니다. ATK 구현체는 <type>MYATKIMP_TYPE_MYTYPE</type>이라고 하겠습니다. <type>MYATKIMP_TYPE_MYTYPE_FACTORY</type> 라고 하는 팩토리 객체가 필요합니다.</para>
<para>GTK 객체의 ATK 구현체를 등록하려면, 모듈의 <function>gtk_module_init()</function> 함수에서 다음 단계를 따라야합니다:</para>
<orderedlist>
<listitem>
<para>기본 레지스트리에 접근하십시오:</para>
<programlisting>
default_registry = atk_get_default_registry();
</programlisting>
</listitem>
<listitem><para>이 함수 호출을 만들어 이 모듈의 <function>gtk_module_init()</function> 함수에 ATK 객체를 등록하십시오:</para>
<programlisting>
atk_registry_set_factory_type (default_registry, GTK_TYPE_MYTYPE, 
MYATKIMP_TYPE_MYTYPE_FACTORY); 
</programlisting>
</listitem>
</orderedlist>
<para><type>GTK_TYPE_MYTYPE</type>의 AtkObject 구현체를 <type>MYATKIMP_TYPE_MYTYPE_FACTORY</type>에 등록합니다. 이 팩토리 객체는 <type>MYATKIMP_TYPE_MYTYPE</type> 형식 객체를 만드는 방법을 구현합니다.</para>
</section>

<section>
<title>팩토리 객체</title>
<para>팩토리 객체는 <type>ATK_TYPE_OBJECT_FACTORY</type> 클래스 형식의 하위 형식과 <function>create_accessible()</function> 함수를 구현해야 합니다. 앞서 언급한 함수는 적절한 <type>AtkObject</type> 객체를 만들어야합니다. 팩토리 객체는 하나 이상의 형식 객체를 만들 때 활용할 수 있으며 <function>create_accessible()</function> 함수는 객체 빌드 과정에서 출분히 알아서 잘 동작해야 하고 올바른 <type>AtkObject</type> 객체를 반환해야합니다.</para>
</section>

<section>
<title>개별 객체의 ATK 구현 처리</title>
<para>모든 <type>GObject</type> 객체는 <function>get_type()</function> 함수를 구현합니다. 이 함수 이름에 대해 이름 규칙을 적용하면 <function>myatkimp_mytype_get_type()</function>이 됩니다.</para>
<para>이 함수에서, 객체 구현체의 인터페이스를 지정합니다. 다음 로직이 <function>get_type()</function> 함수에 있다면, 이 객체는 <type>ATK_TEXT</type> 인터페이스를 구현합니다:</para>
<example>
<title><function>get_type()</function> 함수 예제</title>
<programlisting>
static const GInterfaceInfo atk_text_info = 
{ 
   (GInterfaceInitFunc) atk_text_interface_init, 
   (GInterfaceFinalizeFunc) NULL, 
   NULL 
}; 

g_type_add_interface_static (type, ATK_TYPE_TEXT, 
                             &amp;atk_text_info); 
</programlisting>
</example>
<para>다음 프로토타입을 보유한 <function>atk_text_interface_init()</function> 함수도 구현해야합니다:</para>
<programlisting>
void atk_text_interface_init (AtkTextIface *iface); 
</programlisting>
<para>이 함수는 다음과 같이 인터페이스 함수 호출을 개별 구현체에 연결합니다:</para>
<example>
<title>AtkObject 구현체에 개별 인터페이스 호출 연결</title>
<programlisting>
void 
atk_text_interface_init (AtkTextIface *iface) 
{ 
   g_return_if_fail (iface != NULL); 
   iface-&gt;get_text = myatkimp_mytype_get_text; 
   iface-&gt;get_character_at_offset = myatkimp_mytype_get_character_at_offset; 
   ... 
}
</programlisting>
</example>
<para>그 다음 <function>myatkimp_mytype_get_text()</function> 함수, <function>myatkimp_mytype_get_character_at_offset()</function> 함수, <type>ATK_TEXT</type> 인터페이스 함수의 나머지 부분을 구현해야합니다.</para>
</section>

<section>
<title><type>AtkObject</type> 구현</title>
<para><type>AtkObject</type>는 <type>GObjects</type>이며, 모든 <type>GObject</type>는 <function>get_type()</function> 함수를 지정해야합니다. 클래스 및 인스턴스 초기화 처리자를 설정하는 예제를 보여드리겠습니다. 여기서 <function>get_type()</function> 함수는 <type>ATK_TEXT</type> 객체 구현체를 지정하며, <type>MYATKIMP_MYPARENTTYPE</type>이 될 상위 객체도 지정합니다.</para>
<example>
<title><function>get_type()</function> 구현 예제</title>
<programlisting>
GType 
myatkimp_mytype_get_type (void) 
{ 
   static GType type = 0; 

   if (!type) 
   { 
      static const GTypeInfo tinfo = 
      { 
         sizeof (GailLabelClass), 
         (GBaseInitFunc) NULL,                              /* base init */ 
         (GBaseFinalizeFunc) NULL,                          /* base finalize */
         (GClassInitFunc) myatkimp_mytype_class_init,       /* class init */ 
         (GClassFinalizeFunc) NULL,                         /* class finalize */ 
         NULL,                                              /* class data */ 
         sizeof (GailLabel),                                /* instance size */ 
         0,                                                 /* nb preallocs */ 
         (GInstanceInitFunc) myatkimp_mytype_instance_init, /* instance init */ 
         NULL                                               /* value table */ 
      }; 

      /* Set up atk_text_info structure used below */ 
      static const GInterfaceInfo atk_text_info = 
      { 
         (GInterfaceInitFunc) atk_text_interface_init, 
         (GInterfaceFinalizeFunc) NULL, 
         NULL 
      }; 

      /* Set up typename and specify parent type */ 
      type = g_type_register_static (MYATKIMP_MYPARENTTYPE, 
            "MyatkimpMytype", &amp;tinfo, 0); 

      /* This class implements interface ATK_TYPE_TEXT */ 
      g_type_add_interface_static (type, ATK_TYPE_TEXT, 
                                   &amp;atk_text_info); 
   } 
   return type; 
} 
</programlisting>
</example>
</section>

<section>
<title>클래스/인스턴스 초기화 처리자</title>
<para><type>AtkObject</type> 구현체가 다음에 해당하는 경우 <type>GObject</type>용 클래스 초기화 처리자를 설정해야합니다:</para>
<orderedlist>
<listitem>
<para>상위 객체에서 정의한 함수 호출을 재정의합니다. 객체에 <function>atk_object_get_n_accessible_children()</function> 함수와 비슷한 함수를 구현해야 할 때 보통 필요합니다. 객체가 하위 요소지만 위젯을 나타내지 않는다면 필요합니다.</para>
<para>예를 들어 ATK 구현체에서 <type>AtkObject</type> 함수 <function>get_name()</function>을 따로 구현해야 할 경우, 클래스 초기화 처리자는 다음과 같이 구현합니다:</para>
<example>
<title>상위 객체의 <function>get_name()</function> 함수를 재구현하는 클래스 초기화 처리자</title>
<programlisting>
myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
  AtkObjectClass *class = ATK_OBJECT_CLASS (klass); 
  class-&gt;get_name = myatkimp_mytype_get_name; 
} 
</programlisting>
</example>
</listitem>
<listitem><para><function>parent-&gt;init</function>, <function>parent-&gt;notify_gtk</function>, <function>parent-&gt;finalize</function> 셋 중 한가지 함수가 필요합니다. 다음 예제에서는 언급한 세가지 함수를 모두 정의합니다:</para>
<example>
<title><function>init()</function>, <function>notify_gtk()</function>, <function>finalize()</function> 자체 함수를 정의하는 클래스 초기화 처리자</title>
<programlisting>
static ParentObjectType *parent_class = NULL; 

myatkimp_mytype_class_init (GailLabelClass *klass) 
{ 
   ParentObjectType *parent_class = (ParentObjectType*)klass; 

   /* 
    * Caching the parent_class is necessary if the init, 
    * notify_gtk, or finalize functions are set up. 
    */ 
    parent_class = g_type_class_ref (MYATKIMP_TYPE_PARENT); 

    parent_class-&gt;init = myatkimp_mytype_widget_init; 
    parent_class-&gt;notify_gtk = myatkimp_mytype_real_notify_gtk; 
    parent_class-&gt;finalize = myatkimp_mytype_finalize; 
}
</programlisting>
</example>
<orderedlist>
<listitem>
<para>parent-&gt;init</para>
<para>ATK 구현체에서 다음 두가지 경우가 필요한 경우 <function>parent-&gt;init()</function> 함수가 필요할 수도 있습니다:</para> 
<orderedlist>
<listitem>
<para>보조 GTK 위젯에서 가져온 데이터를 캐시할 경우.</para>
</listitem>
<listitem>
<para>보조 GTK 위젯에서 보낸 시그널을 기다릴 경우.</para>
</listitem>
</orderedlist>
<para>두 가지 모두의 경우에 대한 예제입니다:</para>
<example>
<title><function>init()</function> 개별 구현 함수</title>
<programlisting>
void 
gail_tree_view_widget_init (MyatkimpMytype  *mytype, 
                            GtkWidget       *gtk_widget) 
{ 
   /* Make sure to call the parent's init function */ 
   parent_class-&gt;init (widget, gtk_widget); 
   
   /* Cache a value in the ATK implementation */ 
   mytype-&gt;cached_value = gtk_widget_function_call(); 

   /* Listen to a signal */ 
   gtk_signal_connect (GTK_OBJECT (gtk_widget), 
                       "signal-type", 
                       GTK_SIGNAL_FUNC (_myatkimp_mytype_signal_type), 
                       NULL); 
} 
</programlisting>
</example>
<para>이 예제에서 <type>signal-type</type> 지정 시그널을 보조 <varname>gtk_widget</varname>에서 만들었다면,  <function>_myatkimp_mytype_signal_type()</function>함수를 호출합니다.</para>
</listitem>
<listitem>
<para>parent-&gt;notify_gtk</para>
<para>ATK 구현체에서 보조 GTK 객체의 속성 알림을 기다려야 한다면, <function>parent-&gt;notify_gtk()</function> 함수가 필요할 지도 모르겠습니다. 예를 들어:</para>
<example>
<title><function>notify_gtk()</function> 함수 개별 구현체</title>
<programlisting>
void 
myatkimp_mytype_real_notify_gtk (GObject    *obj, 
                                 GParamSpec *pspec) 
{ 
   GtkWidget *widget = GTK_WIDGET (obj); 
   AtkObject* atk_obj = gtk_widget_get_accessible (widget); 

   if (strcmp (pspec-&gt;name, "property-of-interest") == 0) 
   { 
      /* Handle the property change. */ 
   } 
   else 
   { 
      parent_class-&gt;notify_gtk (obj, pspec); 
   } 
} 
</programlisting>
</example>
</listitem>
<listitem>
<para>parent-&gt;finalize</para>
<para><type>GObject</type> 인스턴스를 무효화 했을 때 데이터를 버려야 한다면 <function>finalize()</function> 함수로 메모리를 해제해야합니다. 예를 들면:</para>
<example>
<title><function>finalize()</function> 함수 개별 구현체</title>
<programlisting>
void 
myatkimp_mytype_finalize (GObject *object) 
{ 
   MyAtkimpMyType *my_type = MYATKIMP_MYTYPE (object); 

   g_object_unref (my_type-&gt;cached_value); 
   G_OBJECT_CLASS (parent_class)-&gt;finalize (object); 
} 
</programlisting>
</example>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
</section>

<section id="gad-custom">
<title>개별 구성 요소 접근성 처리</title>
<para>개별 구현 위젯에 ATK 지원 기능을 추가하면 틀림없이 편의성 기반과 함께 동작합니다. 이에 따라 필요한 몇가지 과정이 있습니다:</para>
<itemizedlist>
<listitem>
<para><link linkend="gad-ui-guidelines">사용자 인터페이스 지침</link>에 해당하는 개별 구현 위젯을 판단합니다.</para>
</listitem>
<listitem>
<para>위젯 특징 및 기능에 따라 어떤 <ulink url="http://library.gnome.org/devel/atk/stable/atk.html">ATK 인터페이스를</ulink> 개별 구현 위젯에 구현해야 할 지 결정합니다.</para>
</listitem>
<listitem>
<para>어떤 <ulink url="http://library.gnome.org/devel/atk/stable/atk.html">ATK 인터페이스</ulink>를 상위 위젯 클래스에서 상속할 수 있는지 판단합니다.</para>
</listitem>
<listitem>
<para>위젯 클래스에 적당한 ATK 인터페이스를 다음 두가지 중 한가지 방법으로 구현하십시오:</para>
<itemizedlist>
<listitem>
<para>개별 구현 위젯으로 바로 처리하거나</para>
</listitem>
<listitem>
<para><ulink url="http://library.gnome.org/devel/atk/stable/AtkObjectFactory.html"><type>AtkObjectFactory</type></ulink> 하위 클래스로 만든 <ulink url="http://library.gnome.org/devel/atk/stable/AtkObject.html"><type>AtkObject</type></ulink> 하위 형식에서</para>
</listitem>
</itemizedlist>
<para>두번째 방식으로 간다면 적절한 팩토리 객체 형식을 실행 도중에 <type>AtkObjectFactoryRegistry</type>로 등록해야합니다.</para>
</listitem>
</itemizedlist>
<para><ulink url="ftp://ftp.gnome.org/pub/GNOME/sources/gail/">GAIL 소스 코드</ulink>에서 고급 ATK 활용법을 언급한 최상의 활용 지침을 제공합니다.</para>
</section>

<section id="gad-ui-guidelines">
<title>접근성 지원 사용자 인터페이스 지침</title>
<para>프로그램 GUI를 설계할 때, 보조 기술과의 연계성과는 관계없이 가능한 한 다양한 사용자가 쓸 수 있도록 따르는 여러 단순 지침서가 있습니다. "GUI를 장애우가 활용할 수 있도록 하는" 경우만 생각하는 어리석음에 빠지지 마시고 장애우가 프로그램을 사용할 일이 없다는걸 알아도 이런 예외를 신경쓰지 않는게 좋습니다. 여러분을 비롯한 모두가 프로그램을 사용할 경우 다음 지침이 전반적인 편의성 개선을 도와줍니다!</para>

<section>
<title>일반</title>
<para>프로그램에서 어떤 기능을 찾을 수 없거나, 모든 설정을 복구할 수 있음에도 설정을 되돌리는데 상당한 시간을 소비하는 실수를 범하면 심히 당황스럽습니다. 여러분의 신체에 어떤 장애가 있다면 노력만이 답이고 이런 부당함으로 인해 상당수의 시간을 허비합니다. 다음 일부 지침은 모든 사용자가 이런 상황을 겪지않게 도와줍니다.</para>
<itemizedlist>
<listitem>
<para>사용자 데이터 또는 프로그램 설정을 바꾸는 모든 동작을 되돌리는 기능을 제공하십시오. 가능하다면, 한 단계 이상의 실행 취소 및 다시 실행 동작, 어떤 동작을 되돌릴 수 없는지 미리 볼 수 있는 기록 목록을 제공하십시오.</para>
</listitem>
<listitem>
<para>기본 설정을 복원하는 명령을 제공하십시오. 일부 설정(글꼴이 매우 작아진다거나)때문에 개인이 프로그램을 완전히 쓰지 못하게 하는 상황을 만들 수 있다면, 프로그램 자체에서보단 프로그램 외부에서 기본 값으로 설정 항목을 복원하게 하는것이 좋습니다. 예를 들자면 이런 수단은 명령행 스위치로 처리할 수 있습니다.</para>
</listitem>
<listitem>
<para>사용자가 잘못된 동작을 수행하지 못하도록 막아주십시오. 갑작스럽게 일어날 수 있는 동작(마우스 동작)이나 쉽게 되돌릴 수 없는(파일 덮어쓰기)동작 같은 경우와 같은 일부의 경우에 중요합니다. 확인 대화상자를 활용하거나 잠재적으로 문제를 일으키는 동작을 수행하는 개별 모드를 사용자가 개별적으로 처리하도록 강제하는 방안을 고려하십시오.</para>
</listitem>
<listitem>
<para>사용자 메모리 사용량을 최소화하십시오. 예를 들어 사용자가 여러 문서를 동시에 보게 하시고, 사용자가 설명 내용을 따르는 동안 온라인 도움말 또는 다른 절차를 볼 수 있게 하십시오. 나타난 어떤 내용이든 복사하고 입력할 수 있는 데이터를 어디든 붙여넣을 수 있게 하십시오.</para>
</listitem>
<listitem>
<para>사용자에게 디스크 삽입 동작을 요구하지 마십시오. 사용자의 신체 장애 여부에 따라 디스크를 넣거나 바꾸는 동작이 실제로 어려울 수 있든지, 그 전에 올바른 디스크를 알아내는 과정도 어려울 수 있습니다. 프로그램을 CD-ROM으로 설치했다면, 모든 파일을 사용자의 하드 드라이브에 복사하도록 요구하는 단계를 제공하십시오.</para>
</listitem>
<listitem>
<para>자주 사용하는 기능을 메뉴 깊숙한 곳에 두지 마십시오. 마우스를 사용하든, 키보드 또는 어떤 입력장치를 사용하든 깊은 곳에 들어간 메뉴 항목은 가장 꺼려하는 부분입니다. 해당 항목이 어디있는지 반복해서 기억하는만큼, 언제든 어렵고 접근하는데 시간이 걸립니다.</para>
</listitem>
<listitem>
<para>사용자로 하여금 불필요한 과정을 거치게 하지 마십시오. 예를 들어, 마법사 도구는 수많은 설정 항목에 불편을 느끼는 사용자에게 한번에 처리할 수 있도록 하는 목적으로 요긴하지만, 어떤 사용자에겐 시간을 아끼고, 키 누름 횟수를 최소화할 목적으로 필요합니다. 어떤 사용자는 불필요한 단계를 건너뛸 수 있거나 필요한 과정으로 바로 건너뛰는게 이득입니다. 마지막 단계로 바로 건너뛰는 <guibutton>완료</guibutton>  단추의 배치를 고려하시고 중간 단계의 기본 응답을 가정하십시오. 여러 단계를 거쳐야 한다면, 사용자가 해당 단계를 다 거쳐갈 지, 일반적인 설정을 활용할 지 질문하는 방안을 고려하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>키보드 탐색</title>
<para>제대로 설계한 키보드 사용자 인터페이스는 여러분의 편의성을 지닌 프로그램을 설계할 때 키 동작을 적절하게 수행합니다. 시각 장애우는 키보드를 사용하는 방식이 프로그램 기능을 탐색하는 방법으로 더 효율적일 수 있는데, 마우스를 활용할 때 마우스 포인터 위치의 시각 반응에 의지해야 하기 때문입니다. 또한, 거동 장애우에겐 마우스 활용이 프로그램 탐색기능에 걸림돌이 되는데, 미세한 전동기 조종 기술이 필요하기 때문입니다.</para>
<para>따라서 모든 마우스 동작을 모든 도구 모음, 메뉴, 링크, 단추로의 키보드 접근 동작으로 처리할 수 있게 조치하는게 중요합니다. 프로그램의 모든 동작은 키보드로만으로도 사용할 수 있어야합니다. 프로그램을 시험하는 동안 키보드를 시험한다면 마우스를 숨겨두십시오!</para>
<para>대부분의 기능은 키보드 단축키, 도구 모음의 내장 탐색 기능으로 쉽게 접근할 수 있어야 합니다. 허나 끌어다 놓기에 의존하는 동작의 경우는 좀 더 생각이 필요합니다.</para>
<itemizedlist>
<listitem>
<para>모든 프로그램 기능에 대한 효율적인 키보드 접근 기능을 제공하십시오. 일부 사용자는 마우스를 사용할 수 없을지도 모르며, 대부분의 "고급 사용자"는 어쨌거나 키보드 활용을 더 좋아합니다. 게다가 일부 특화된 보조 기술 입력 장치의 경우 마우스 동작보단 키보드 동작을 흉내냅니다. 일부 사용자에겐 어렵거나 괴로울 수 있으므로, 주어진 동작을 처리할 경우 키 누름 횟수를 최소화 한 키보드 인터페이스를 제공하는 것이 중요합니다.</para>
</listitem>
<listitem>
<para>논리적인 키보드 탐색 순서를 활용하십시오. <keycap>탭</keycap>키고 창을 둘러볼 때, 키보드 포커스는 예상 가능한 순서대로 컨트롤을 가리키며 움직여야합니다. 서부 유럽 로캘의 경우, 보통 왼쪽에서 오른쪽으로, 그리고 상단에서 하단으로 움직입니다.</para>
</listitem>
<listitem>
<para>확인 상자, 라디오 단추, 토글 상태 단추의 활성 여부에 따라 컨트롤 탭 순서가 올바른지 확인하십시오. 일부 단추를 선택하면, 관련 컨트롤을 활성화해야 하며, 그룹에 있는 다른 단추와 관련한 컨트롤은 비활성화해야합니다. 사용자가 컨트롤에 따른 확인 상자, 라디오 단추, 토글 단추를 선택하면 첫번째 관련 컨트롤에 포커스를 주지 마시고 단추에 포커스가 올라간 상태 그대로 두십시오.</para>
</listitem>
<listitem>
<para>기존의 시스템 차원의 편의 기능을 무시하고 새로 적용하지 마십시오. <ulink url="http://www.rehab.uiuc.edu/accessx/overview.html">AccessX</ulink>은 X11R6부터 지원하는 X 서버 확장 기능입니다. 이 확장 기능의 마우스 키 기능은 마우스 커서 이동 및 단추 누르기 동작을 키 패트로 흉내냅니다. 따라서 키 패드의 키를 눌러 접근할 수 있는 프로그램의 기능을 별도로 추가하면 마우스 키 기능을 활용할 수 없기 때문에 프로그램에 기능에 접근할 수 있도록 하는 키패드 접근 기능을 추가하면 안됩니다.</para>
</listitem>
<listitem>
<para>가능하다면 키보드 동작을 처리할 방법을 한가지 이상 제공하십시오. 어떤 사용자는 일부 키 및 단축키를 찾는게 다른 방편보다 쉬울 수도 있습니다.</para>
</listitem>
<listitem>
<para>가능하다면 기능을 활용할 때 키보드 마우스 둘 다 활용하여 접근할 수 있도록 하십시오. 어떤 사용자는 마우스 또는 키보드 둘 다 사용할 수 있거나 둘 중 하나로만 접근할 수도 있습니다.</para>
</listitem>
<listitem>
<para>자주 활용하는 키보드 동작에 불편한 방식을 할당하지 마십시오. 어떤 사람은 키보드를 한손으로만 활용할 수 있어, 일반 동작은 한손으로 쉽게 활용할 수 있게 하는게 적절합니다. 일부 경우에는 길게 누르거나 손이 닿기 어려운 방식으로 자주 사용하는 기능에 접근할 수 있게 하면, 모든 사용자에게 근육통, 부상 가능성이 늘어날 수 있습니다.</para>
</listitem>
<listitem>
<para>동시 키 누름을 반복적으로 요구하지 마십시오. 일부 사용자는 한번에 키 하나만 누를 수 있습니다. AccessX 같은 보조 기술은 키를 동시에 누르기보단 순차적으로 누를 수 있게 하는데 이런 방편은 키를 눌러 조작하는데 시간이 좀 더 걸릴 수 있습니다.</para>
</listitem>
<listitem>
<para>마우스로 선택할 수 있는 텍스트를 키보드로도 선택할 수 있는지 확인하십시오. 모든 사용자의 편의 수단이지만, 특히 마우스 사용이 불편한 이들에게 바람직한 제어 수단이 될 수 있습니다.</para>
</listitem>
<listitem>
<para>마우스 끌어다 놓기 동작으로 크기를 조절하거나 움직일 수 있는 객체를 키보드로도 크기를 조절하거나 움직일 수 있는지 확인하십시오. 이를테면, 데스크톱의 아이콘 및 창이 있습니다. 좌표를 입력하는 대화상자를 제공하거나 사용자가 설정할 수 있는 그리드에 객체를 잡아두는 수단을 제공하여 다이어그램의 모양새를 다루는 것처럼 객체의 정확한 크기 조절 및 위치 지정은 어쨌든 중요합니다.</para>
</listitem>
<listitem>
<para>동작을 실행할 때 일반 탐색 기능을 활용하지 마십시오. 예를 들자면, 대화상자 상에서 기본적인 <keycap>Tab</keycap> 키보드 탐색 기능을 컨트롤과 관련한 어떤 동작에든 활용하지 마십시오.</para>
</listitem>
<listitem>
<para>키보드로 실행한 메뉴, 창, 풍선 도움말을 관련 객체 주위에 나타내십시오. 그놈 2.0에서는 <keycombo><keycap>Shift</keycap><keycap>F10</keycap></keycombo> 키로 단축 메뉴를 띄울 수 있고, <keycombo><keycap>Shift</keycap><keycap>F1</keycap></keycombo> 키로 풍선 도움말을 띄울 수 있습니다. 허나 메뉴 또는 풍선 도움말을 참고하는 객체를 완전히 숨기거나 애매하게 나타내지 마십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>마우스 동작</title>
<para>모든 사람이 동일한 마우스 활용 능력을 갖춘게 아니며 일부 사용자는 마우스 포인터를 따라가보는데 어려움이 있습니다.</para>
<itemizedlist>
<listitem>
<para>두번째 또는 세번째 마우스 단추 입력에 의존하지 마십시오. 실제로 누르기 어려운 만큼 일부 지시 장치 및 많은 보조 기술 장치에서는 단추 하나만 지원합니다. 일부 보조 기술은 마우스 동작을 완전히 흉내내는건 아니지만 키보드 동작을 대신 흉내냅니다.</para>
</listitem>
<listitem>
<para>마우스 동작을 취소할 수 있게 하십시오. 파일 관리자에서 파일을 끌어다 놓거나 그림 프로그램에서 도형을 그리는 등의 마우스 동작 진행시 <keycap>Esc</keycap> 키를 누르면 취소할 수 있어야합니다.</para>
</listitem>
<listitem>
<para>끌어다 놓기 동작을 처리할 때 시각 반응 기능을 넣으십시오. 마우스 커서를 올바른 대상으로 옮길 때 해당 위치를 강조하고 마우스 포인터 모양새를 바꾸십시오. 잘못된 대상 위치로 마우스 포인터를 옮겼다면 "놓을 수 없음" 마우스 포인터 커서를 활용하십시오. <link linkend="gad-mouse-examples">마우스 동작 예제</link>를 참고하십시오.</para>
</listitem>
<listitem>
<para>마우스 포인터를 멋대로 옮기거나 화면 일부 영역으로 마우스 움직임을 제한하지 마십시오. 보조 기술을 활용할 때 혼란감을 줄 수 있으며 AT에 의존하지 않는 사용자에게도 혼란감을 안겨줍니다.</para>
</listitem>
<listitem>
<para>마우스 처리 대상을 너무 작게 만들지 마십시오. 보통 마우스 처리 대상은 현재 창 관리자/테마의 크기 조절 가능 창 테두리 주변에 있는 "강조 영역"의 최소한의 크기여야 합니다. 거동 또는 시각이 불편한 사용자는 기준치보다 더 크고 넓은 영역을 차지하는 창 관리자를 사용한다는 사실을 숙지하십시오.</para>
</listitem>
</itemizedlist>

<section id="gad-mouse-examples">
<title>마우스 동작 예제</title>
<figure>
<title>CDE/Motif에서 "놓을 수 없음" 포인터 예제</title>
<mediaobject><imageobject> <imagedata fileref="figures/nodrop.png" format="PNG"/> </imageobject> <textobject> <phrase>"잘못된 놓기 대상" 포인터 모양 예제</phrase> </textobject></mediaobject>
</figure>
</section>
</section>

<section>
<title>그래픽 요소</title>
<para>프로그램에서 중요한 모든 그래픽 항목을 프리젠테이션하도록 개별 설정하는 항목을 제공하십시오. 이 설정 항목은 시각 장애우 및 인지 장애우에게 편의성을 제공합니다.</para>
<itemizedlist>
<listitem>
<para>선, 테두리, 그림자 두께 같은 그래픽 속성 값을 코드에 넣지 마십시오. 이 항목은 GTK 또는 창 관리자 테마에서 읽는게 바람직합니다. 만약 그렇게 할 수 없다면 프로그램에서 설정 항목을 제공하여 값을 바꿀 수 있게 하십시오.</para>
</listitem>
<listitem>
<para>모든 인터페이스 구성 요소에 알아볼 수 있는 이름을 넣으십시오. GAIL 라이브러리에서는 GTK 위젯에 기본 편의 설명을 제공하지만, 텍스트 대신 그래픽을 활용하는 위젯(색상 표 또는 레이블 없는 아이콘 과 같은)어떤 경우에는 여러분이 직접 추가해야합니다. 가능한 곳마다 식별에 더 도움을 주거나 프로그램별 설명을 기본으로 넣는 방안을 고려해보십시오.</para>
</listitem>
<listitem>
<para>가능하다면 다중 색상 그래픽 요소(도구 모음 아이콘)를 흑백으로만 볼 수 있게 허용 하십시오. 흑백 이미지는 사용자가(GTK 테마 선택으로) 최대 가독성 확보를 목적으로 선택한 시스템 전경 배경색 사이에서도 나타나야 합니다.</para>
</listitem>
<listitem>
<para>대화식 GUI 요소를 쉽게 식별할 수 있게 하십시오. 객체 클릭 가능 여부를 결정할 목적으로 마우스를 올려놓게 하지 마십시오. 객체간 충분한 공간을 남겨두고 객체 경계를 분명히 하십시오. 실제로 아무 동작도할 수 없는 GUI 요소를 사용할 수 없게 끄는 설정 항목을 제공하기 전에는 예쁘게 보이지 마십시오.</para>
</listitem>
<listitem>
<para>핵심 정보를 전달하지 않는 그래픽은 숨기는 설정 항목을 제공하십시오. 그래픽 이미지는 사용자에게 혼란을 안겨줄 수 있습니다. 예를 들어, 그놈 발 메뉴 아이콘이 없어도 메뉴는 제대로 동작하므로 이 아이콘을 숨길 수 있습니다.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>글꼴 및 텍스트</title>
<para>사용자의 시력이 정상이라 해도 텍스트 출력은 대부분의 프로그램에서 주요 정보이자 반응요소로 제공합니다. 그렇기 때문에 화면에 텍스트를 조심스레 선택하고 배치하는 것이 중요하며, 글꼴 및 크기는 사용자의 선택으로 두고, 시각 장애우가 실질적으로 프로그램을 활용할 수 있는지 확인해보십시오.</para>
<itemizedlist>
<listitem>
<para>글꼴 모양새와 크기를 코드에 넣지 마십시오. 사용자는 모든 글꼴 크기 및 모양새 를 조절할 수 있어야합니다. 어떤 이유로 이 기능을 사용하지 못하게 한다면, 글꼴 크기 값을 10 포인트보다 작게 코드에 넣지 마십시오.</para>
</listitem>
<listitem>
<para>텍스트 뒤에 있는 그래픽 배경 또는 "워터마크"를 없애는 설정 항목을 제공하십시오. 일부 이미지는 텍스트와 배경의 대비 혼동을 주어, 시각 장애우 사용자가 화면의 내용을 알아보는데 어려움을 줍니다.</para>
</listitem>
<listitem>
<para>컨텍스트를 벗어났을 때 상황에 맞게 객체에 이름을 레이블로 붙이십시오. 스크린 리더 또는 유사한 보조 기술에 의지하는 사용자에게는 컨트롤과 컨트롤 주변과의 관계를 즉시 이해하게 할 필요가 없습니다.</para>
</listitem>
<listitem>
<para>동일한 창에 레이블을 하나 이상 붙이지 마십시오. 다른 창에 동일한 레이블을 활용하면 두 창이 동일하다는 의미로 해석할 수 있게 합니다. 또한("Read"나 "Red"와 같은)동음이의어는 스크린 리더에 의지하는 사용자에게 혼동을 주므로 레이블로 활용하지 마십시오.</para>
</listitem>
<listitem>
<para>프로그램에 레이블을 제 위치에 두십시오. 보통 큰 아이콘 아래, 작은 아이콘 오른쪽, 다른 컨트롤의 위 또는 왼쪽에 두라는 의미입니다. <link linkend="gad-font-examples">글꼴 및 텍스트 예제</link>를 참고하십시오.</para>
</listitem>
<listitem>
<para>컨트롤에 정적 텍스트로 이름을 붙일 때, 레이블 마지막을 콜론으로 끝내십시오. 예를 들어 사용자 이름(ID)을 입력할 텍스트 필드에 이름을 붙일 때 <guilabel>사용자 이름:</guilabel>으로 적으십시오. 독립 텍스트, 컨트롤의 레이블의 구분을 돕습니다.</para>
</listitem>
<listitem>
<para>컨트롤에 정적 텍스트로 이름을 붙일 때 탭 순서에 따라 컨트롤의 바로 앞에 레이블을 붙였는지 확인하십시오. 개발자 여러분이 레이블에 할당한 니모닉(밑줄 문자)으로 포커스를 이동하거나 누른 컨트롤을 올바르게 활성화해줍니다.</para>
</listitem>
<listitem>
<para>WYSIWYG 대응 요소를 제공하십시오. 이를테면, 일부 사용자는 작은 글꼴로 텍스트를 인쇄하지만, 편집할 때는 큰 화면 글꼴로 편집합니다.  가능한 대응 요소에는 동일한 글꼴 및 크기(를 사용자가 선택)로 모든 텍스트를 표시하는 방안이 있습니다. "창 폭에 따라 줄바꾸기" 설정 항목은 수평 방향으로 스크롤하지 않아도 창의 모든 텍스트를 볼 수 있게 합니다. 창의 내용을 단일 컬럼에 보여주는 단일 컬럼 보기는 여러 컬럼으로 나타나도 단일 컬럼으로만 표시합니다. 텍스트 전용 보기는 그래픽 요소가 예제 또는 텍스트 설명으로 나타나는 곳에 활용합니다. 프로그램에 하위 컨트롤을 지닌 창이 있다면 상위 창을 따라 패널 크기 조절이 가능하도록 하는 방안을 고려해보십시오.</para>
</listitem>
</itemizedlist>

<section id="gad-font-examples">
<title>글꼴 및 텍스트 예제</title>
<figure id="label-placement-example">
<title>다양한 GUI 요소의 올바른 레이블 위치</title>
<informaltable frame="all">
<tgroup cols="3" align="center">
<tbody>
<row>
<entry valign="middle"><mediaobject>
<imageobject>
<imagedata fileref="figures/label_above.png" format="PNG"/>
</imageobject>
<textobject>
<phrase>List control with label above</phrase>
</textobject>
</mediaobject> 레이블이 상단에 있는 리스트 컨트롤</entry>
<entry valign="middle"><mediaobject>
<imageobject>
<imagedata fileref="figures/label_below.png" format="PNG"/>
</imageobject>
<textobject>
<phrase>Large file manager icon with label underneath</phrase>
</textobject>
</mediaobject> 레이블이 하단에 있는 큰 파일 관리자 아이콘</entry>
<entry valign="middle"><mediaobject>
<imageobject>
<imagedata fileref="figures/label_right.png" format="PNG"/>
</imageobject>
<textobject>
<phrase>Small toolbar icon with label to its right</phrase>
</textobject>
</mediaobject> 레이블이 우측에 있는 작은 도구 모음 아이콘</entry>
<entry valign="middle"><mediaobject>
<imageobject>
<imagedata fileref="figures/label_left.png" format="PNG"/>
</imageobject>
<textobject>
<phrase>Spinbox control with label to its left</phrase>
</textobject>
</mediaobject> 레이블이 좌측에 있는 스핀 상자 컨트롤</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</figure>
</section>
</section>

<section>
<title>색상 및 대비</title>      
<para>잘못된 화면 색상 선택은(색상이 중요한) 색맹 사용자 또는 근시 사용자(명도/대비가 중요)에게 불편을 초래할 수 있습니다. 보통 사용자가 프로그램 일부의 색상을 직접 설정하여 프로그램에서 중요한 정보를 명확하게 나타낼 수 있게 해야합니다.</para>
<para>시각 장애우 사용자는 배경과 텍스트 색상의 고대비 처리가 필요합니다. 배경 색상으로 "충혈"이 일어나는 상황을 피하려 종종 검은 바탕에 흰 글씨를 사용합니다. 이 설정은 시각 장애우 사용자에게 매우 중요합니다.</para>
<itemizedlist>
<listitem>
<para>프로그램 색상 설정 값을 코드에 넣지 마십시오. 일부 사용자는 화면을 편하게 보려고 색상 조합과 대비 값을 설정해야합니다.따라서 그놈 프로그램에서 활용하는 모든 주요 색상은 GTK 테마에서 가져와야 하며, 단지 테마만 바꾸는 과정을 통해 프로그램의 모든 내용을 또렷하게 볼 수 있도록 색상을 설정할 수 있습니다. 어떤 이유로 테마에 없는 색상을 사용해야 한다면, 프로그램 자체에서 설정할 수 있는지 확인하십시오.</para>
</listitem>
<listitem>
<para>정보 항목을 식별하는 목적 만드로 색상을 활용하지 마십시오. 모든 해당 정보는 최소한 도형, 위치, 텍스트 설명 등 한가지 이상의 방식으로 제공해야합니다. <link linkend="gad-color-examples">색상 대비 예제</link>를 참고하십시오.</para>
</listitem>
<listitem>
<para>모든 고대비 그놈 테마를 지원하십시오. 고대비 테마중 하나를 설정하면 프로그램의 모든 텍스트를 테마에서 정한 전경, 배경색의 고대비로 나타나는지 확인하십시오.</para>
</listitem>
<listitem>
<para>프로그램이 일부 고대비 테마에 의존하지 않는지 확인하십시오. 여러가지 고대비 테마로 시험하여 프로그램이 설정 상태를 만족하는지 확인하십시오.</para>
</listitem>
</itemizedlist>

<section id="gad-color-examples">
<title>색상 및 대비 예제</title>
<example>
<title>색상 중복 사용 표현 예제</title>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/color_only.png" format="PNG"/> </imageobject> <textobject> <phrase>색상만 활용하여 주가 변동을 보여주는 예제</phrase> </textobject></mediaobject>
</entry>
<entry>이 화면은 적녹 색맹 사용자(전세계 7명중 1명의 남성에게 생맥 증상이 있음)에게 문제를 일으킬 수 있습니다. 대비가 떨어지는 적색 글씨와 흑색 배경은 화면 돋보기를 활용한다 해도 저시력 사용자가 알아보기 어렵게 합니다.</entry>
</row>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/color_and_arrows.png" format="PNG"/> </imageobject> <textobject> <phrase>색상 및 화살표를 활용하여 주가 변동을 보여주는 예제</phrase> </textobject></mediaobject>
</entry>
<entry>주가 변동을 보여줄 때 색상 표시에 화살표를 넣어 보강한 화면이며, 녹색, 적색에 어두운 그림자를 넣고 배경을 밝게 하여 대비를 늘렸습니다. 주요 사용자가 보기에 꺼림칙한 반응을 보이기에 기본 색상 배치로 둘 필요는 없지만, 테마를 지정하거나 프로그램 <guilabel>기본 설정</guilabel> 대화상자를 통해 개별적으로 설정할 수 있습니다.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
</section>
</section>

<section>
<title>확대/축소</title>
<para>대부분의 사용자는, 심지어 시각 장애우들에게는, 텍스트 및 그래픽 돋보기의 도움을 받습니다. 허나 돋보기가 없으면 시각 장애우는 프로그램을 찾아 활용할 수 없을지도 모릅니다.</para>
<itemizedlist>
<listitem>
<para>사용자가 작업 영역을 확대/축소하는 기능을 제공하십시오.</para>
</listitem>
<listitem>
<para>프로그램에서 작업 영역의 크기를 조절하는 설정 항목을 제공하십시오. 사용자는 작업 영역을 1.5배 내기는 4배 크기로 확대하는 설정 항목이 필요합니다. 돋보기 설정을 바꿀 때 여러분이 바라보는 대상에 영향을 주지 않는지 확인하여 프로그램을 시험해보십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>음성</title>
<para>난청 사용자, 컴퓨터의 소리를 끄고 일하는 사용자에겐 프로그램이 정보를 전달할 때 소리에 의존할 경우 제약을 받습니다. 일반적으로, 사용자가 다른 방식으로 잘 들리는 정보를 접할 수 있는지 확인하십시오.</para>
<itemizedlist>
<listitem>
<para>사용자가 음성 정보를 들을 수 있다고 단정하지 마십시오. 망가진 사운드카드를 보유한 사용자는 물론이고 청각 장애우에게도 해당합니다!</para>
</listitem>
<listitem>
<para>오디오를 단지 정보전달 수단으로만 사용하지 마십시오. 마찬가지로 모든 음성 정보를 시각적인 방법으로 전달하는 설정 항목도 제공하십시오. 일부 중요한 음성 사운드 클립의 자막이나 녹취록도 포함입니다.</para>
</listitem>
<listitem>
<para>모든 경고 비프음과 다른 소리의 재생 주파수와 음량을 사용자가 설정할 수 있게 하십시오. 소리를 모두 끌 수 있는 기능도 포함입니다.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>애니메이션</title>
<para>드물게 활용하는 애니메이션은 프로그램의 중요한 정보를 주목할 요소를 그릴 때 쓸만합니다. 그리고 멋지게 보일 수 있습니다. 허나, 일부 사용자에겐 이게 문제가 될 수 있어, 해당 사용자가 끌 수 있는지 확인하십시오.</para>
<itemizedlist>
<listitem>
<para>번쩍이거나 깜빡이는 요소의 깜빡임 빈도를 초당 2회 이상 55회 미만으로 구현하지 마십시오. 어떤 그래픽 객체와 마찬가지로 텍스트에도 해당합니다. 이 빈도 범위는 시각 요소에 의한 발작에 예민한 사용자에게 문제를 일으킵니다. 참고로 "안전한" 깜빡임 빈도란 없습니다. 깜빡임 동작이 중요하다면 시스템 커서 깜짝임 주기 값(자체적으로 설정할 수 있음)을 활용하거나, 사용자가 깜빡임 빈도를 설정할 수 있게 하십시오.</para>
</listitem>
<listitem>
<para>화면의 대부분 영역을 번쩍이거나 깜빡이게 하지 마십시오. 좁은 영역을 깜빡일 수록 이런 요소에 민감한 사용자의 발작 가능성을 줄입니다.</para>
</listitem>
<listitem>
<para>모든 애니메이션을 따로 설정할 수 있게 하십시오. 움직이는 정보는 최소한 사용자의 요구에 따라 움직이지 않는 형식 하나는 있어야합니다.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>키보드 포커스</title>
<para>시각 장애우 뿐만 아니라 키보드를 마우스보다 더 선호하는 "고급 사용자" 들을 위해 키보드 포커스 위치를 언제나 분명하게 나타내는 것이 중요합니다. 주어진 시간 언제든 데스크톱의 어떤 컨트롤에든 포커스를 올려놓아 혼동을 주지 말아야합니다. 프로그램의 어떤 위젯에든 포커스를 올려놓은 상태에서 컴퓨터 앞을 벗어난 후, 여자친구랑 통화를 한다거나, 다루던 위젯이 어떤 위젯인지 잊을 때까지 개랑 산책을 할 수 있어야겠지요. 돌아온 다음에는 어떤 위젯을 다루고 있었는지 바로 알아볼 수 있도록 나타내야합니다.</para>
<para>시각 포커스 표시는 데스크톱의 다른 객체와 관계된 커서 위치의 음성 표현입니다. 이 수단 덕분에 포커스 위치가 바뀌어도 사용자가 어떤 객체에 대해서든 이리저리 포커스를 옮길 수 있습니다. 시각 포커스는 보조 기술에 프로그램상에서 노출해야합니다. 대부분의 경우 ATK에서 별도로 처리해야 할 일 없이 자동으로 처리해줍니다. 하지만 개별 위젯을 자체적으로 작성한다면 다음 과정이 필요합니다.</para>
<itemizedlist>
<listitem>
<para>주로 활용하는 컨트롤에 포커스를 두어 시작하십시오. "가장" 쓸모있는 창의 컨트롤이 없는 것 같다면, 창을 열었을 때 가장 먼저 나타나는 컨트롤에 포커스를 두십시오. 대화 상자의 <guilabel>확인</guilabel> 단추 또는 <guilabel>취소</guilabel> 단추는 <keycap>Enter</keycap>키 또는 <keycap>Escape</keycap> 키로 바로 언제든 활성화할 수 있기 때문에 대부분 주로 활용 하는 컨트롤이라 해도 우선적으로 포커스를 두면 안됩니다.</para>
</listitem>
<listitem>
<para>언제든 현재 입력 위치에 포커스를 분명하게 보여주십시오. 스크롤 요소가 있는 컨트롤에서는 스크롤 영역안에서 선택하여 강조한 요소를 나타나지 않을 때도 있으므로 항상 만족스럽진 않을지도 모릅니다. <link linkend="gad-focus-examples">키보드 포커스 예제</link>를 참고하십시오.</para>
</listitem>
<listitem>
<para>활성 창의 입력 포커스만 보여주십시오. 포커스가 없거나 활성화하지 않은 모든 창의 기본 시각 포커스 표시는 숨겨두십시오. 단일 창에 분할 창이 있다면, 하나의 창에 포커스 표시를 두시고, 다른 창의 포커스 표시는 숨겨야합니다. 포커스를 올려두지 않은 목록에서 어떤 항목을 계속 선택할 경우 중요한데 이때 2차 포커스 표시를 활용하십시오. <link linkend="gad-focus-examples">키보드 포커스 예제</link>를 참고하십시오.</para>
</listitem>
<listitem>
<para>관련 객체 그룹의 마지막 이전을 탐색하려 할 경우 적당한 반응 요소를 제공하십시오. 목록을 탐색할 경우 음성을 출력하면서 멈추면 목록의 처음 객체로 포커스를 되돌라는 것보다 낫습니다. 그렇지 않으면, 장님, 저시력자의 경우 처음으로 돌아왔는지 깨닫지 못합니다. 문서에서 텍스트를 검색할 때 문서의 마지막에 도달하면 대화 상자가 나타나고 문서의 처음 부분부터 다시 검색할 지 물어봅니다.</para>
</listitem>
<listitem>
<para>사용자가 부적절한 키를 눌렀을 때 또는 탐색 키 조작 과정에서 포커스 이동에 실패했을 경우 시스템 기본 소리 또는 시각 경고 표시를 재생하십시오. 포커스가 텍스트 필드의 첫번째 문자에 둔 상태에서 왼쪽 화살표 키를 누르거나 단일 선택 대화상자에서 여러 요소 선택을 시도할 경우를 예로 들어볼 수 있습니다(난청 사용자는 기본 경고음과 동일한 시스템 시각 알림을 설정할 수 있어야합니다).</para>
</listitem>
</itemizedlist>

<section id="gad-focus-examples">
<title>키보드 포커스 예제</title>
<example><title>포커스를 분명하게 보여줄 부분을 표현하는 예제</title>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/badfocus1.png" format="PNG"/> </imageobject> <textobject> <phrase>이 창에서 포커스를 올려둔 항목은 화면 밖으로 스크롤을 통해 나갔기 때문에 나타낼 수 없습니다</phrase> </textobject></mediaobject>
</entry>
<entry>이 창에 있는 컨트롤 하나에 포커스를 두었지만 다음과 같이 할 수는 없습니다...</entry>
</row>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/badfocus2.png" format="PNG"/> </imageobject> <textobject> <phrase>목록에 포커스를 올려둔 항목은 목록을 스크롤 하여 뷰에 나타냅니다</phrase> </textobject></mediaobject>
</entry>
<entry>...현재 선택한 항목을 나타내는 목록을 스크롤 하기 이전까지.</entry>
</row>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/goodfocus.png" format="PNG"/> </imageobject> <textobject> <phrase>이 예제의 리스트 컨트롤은 포커스를 나타내는 선 테두리가 있으며, 선택한 항목을 볼 수 있는지 없는지를 나타냅니다</phrase> </textobject></mediaobject>
</entry>
<entry>리스트 컨트롤 자체에 "포커스" 테두리가 있다면, 현재 선택한 항목이 나타나지 않을 경우 포커스가 있음을 쉽게 알릴 수 있습니다.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
<example>
<title>2차 포커스 표현 예제</title>
<informaltable frame="all">
<tgroup cols="2">
<tbody>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/badfocus3.png" format="PNG"/> </imageobject> <textobject> <phrase>두 창에 포커스를 올려놓은 것 같은 분할 창</phrase> </textobject></mediaobject>
</entry>
<entry>이 예제에서, 실제로 키보드 포커스를 지닌 두개의 창을 바라보기란 불가능합니다.</entry>
</row>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/goodfocus3.png" format="PNG"/> </imageobject> <textobject> <phrase>어떤 창에 포커스를 올려놓았는지 보여주는 2차 강조 분할 창</phrase> </textobject></mediaobject>
</entry>
<entry>비활성 창의 2차 선택 강조 색상을 활용하여 트리 컨트롤에 포커스를 올려놓았음을 단박에 알아채게 했습니다...</entry>
</row>
<row>
<entry valign="middle">
<mediaobject><imageobject> <imagedata fileref="figures/goodfocus2.png" format="PNG"/> </imageobject> <textobject> <phrase>어떤 창에 포커스를 올려놓았는지 보여주는 2차 강조 분할 창</phrase> </textobject></mediaobject>
</entry>
<entry>...그리고 리스트 컨트롤에 포커스를 주었습니다.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</example>
</section>
</section>

<section>
<title>타이밍</title>
<para>코드로 직접 제한 시간을 넣어 인터페이스를 나타내거나 숨기거나 하면 종종 접근성을 떨어트립니다. 일부 사용자는 다른 사용자에 비해 읽고 입력하고 반응하는 일련의 동작이 상당히 느립니다. 사용자가 필요한 정보를 끝까지 확인하기 전에 숨기거나 분명하게 요청하지 않은 내용이 떠서 가린다면, 프로그램 사용자는 상당한 불만을 느끼거나 사용하지 않을 수도 있습니다.</para>
<itemizedlist>
<listitem>
<para>제한 시간 또는 다른 시간 기반 기능을 코드에 직접 넣지 마십시오. 창 가장자리를 따라 스크롤 바 단추를 잡고 끌어 내릴 때 자동으로 움직이는 경우 또는 객체를 트리 구조에 올려놓으면 짧은 시간에 펼쳐지는 경우를 예로 들어보겠습니다. 이와 같은 경우는 그놈 제어 센터 프로그램에서 자체적으로 설정할 수 있어야 하거나 최악의 경우에는 설정 파일 또는 GConf 항목을 통해 명령행에서 직접 설정할 수 있어야합니다.</para>
</listitem>
<listitem>
<para>마우스 포인터의 움직임에 따라 정보를 간단하게 보이거거나 숨기지 마십시오(예외: 시스템에서 전반적으로 사용자가 설정할 수 있게 풍선 도움말로 제공하는 기능).제각각의 기능을 제공해야 한다면, 별도의 설정 항목으로 만들어 사용자가 화면 검토 유틸리티를 설정했을 때 켜고 끌 수 있게 하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>문서</title>
<para>신체적 불편을 지닌 사람은 필요한 설명서와 도움말 파일을 볼 수 없다면 프로그램을 제대로 활용할 수 없습니다. 대부분의 사용자에게 프로그램을 둘러볼 수 있게 하는 키보드 탐색 기능은 특히 중요한 측면이 있습니다.</para>
<itemizedlist>
<listitem>
<para>접근 가능한 모든 형식으로 문서를 제공하십시오. ASCII 텍스트 및 HTML 형식 둘 다 보조 기술에 최적인 형식입니다.</para>
</listitem>
<listitem>
<para>문서에 모든 그래픽 구성요소에 대한 대체 텍스트 설명을 붙이십시오.</para>
</listitem>
<listitem>
<para>프로그램의 모든 접근성 기능을 문서로 기록하십시오. 키보드 탐색 기능 및 바로 가기 키는 문서에서 특히 중요합니다.문서에 모든 편의성 기능 설명을 제공하는 접근성 부분을 넣으십시오.</para>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>

<chapter id="gtest" status="draft">
<title>시험</title>
<para>프로그램 접근 가능성을 선언하기 전 몇가지 검토해볼 접점이 있습니다. 개발을 진행하는 동안 시험 기술 자동화를 고려해볼 수도 있습니다. 예를 들어 <ulink url="http://ldtp.freedesktop.org/">LDTP</ulink>에서는 지동화 시험 계획을 보조합니다.</para>
<para>이 부분에서는 프로그램에서 직접 시험해볼 수 있는 몇가지 접근성 테스트를 언급합니다. 프로그램의 편의성을 완벽하게 갖추는데 있어 모든 시험을 통과할 필요는 없지만, 어떤 시험 항목을 통과하지 못하면 편의성 관점에서 개선해야 할 어떤 일이 있을 수도 있습니다.</para>

<section>
<title>키보드 탐색</title>
<para>다음 키보드 동작을 시험하십시오. 어떤 부분에 있어서도 시험 과정에서 마우스를 사용하지 마십시오.</para>
<itemizedlist>
<listitem>
<para>키보드 명령만 사용하여 프로그램의 모든 메뉴 표시줄의 포커스를 이동하십시오.</para>
</listitem>
<listitem>
<para>다음을 확인하십시오:</para>
<itemizedlist>
<listitem>
<para>상황 기반 메뉴를 올바르게 표시합니다.</para>
</listitem>
<listitem>
<para>도구 모음에 나타난 어떤 기능도 키보드로 처리할 수 있습니다.</para>
</listitem>
<listitem>
<para>프로그램의 클라이언트 영역 및 대화상자를 모두 제어할 수 있습니다.</para>
</listitem>
<listitem>
<para>클라이언트 영역의 모든 텍스트 및 객체를 선택할 수 있습니다.</para>
</listitem>
<listitem>
<para>키보드 부가 기능 또는 바로 가기 키가 설계대로 동작합니다.</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>

<section>
<title>그래픽 요소</title>
<para>스크린 리더를 활용하는 프로그램을 시험하여 다음을 확인하십시오:</para>
<itemizedlist>
<listitem>
<para>메뉴 및 도구모음에 레이블과 텍스트를 올바르게 읽습니다.</para>
</listitem>
<listitem>
<para>객체 정보를 올바르게 읽습니다.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>시각 포커스 표시자</title>
<itemizedlist>
<listitem>
<para>객체간 이동하는 시각 포커스 표시를 쉽게 알아볼 수 있는지 확인하십시오.</para>
</listitem>
<listitem>
<para>포커스를 이동할 때 프로그램 및 메뉴의 키보드 탐색 표시가 분명하게 나타나야합니다.</para>
</listitem>
<listitem>
<para>여러분이 키보드로 이리저리 둘러보는 동안 스크린 리더가 시각 포커스 표시자를 따라가는지 확인하십시오.</para>
</listitem>
<listitem>
<para>(가능하다면)화면 확대 프로그램을 실행하고, 여러분이 키보드로 이리저리 둘러보는 동안 돋보기가 시각 포커스 표시를 따라갈 수 있는지 확인하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>글꼴 및 텍스트</title>
<itemizedlist>
<listitem>
<para>프로그램에서 글꼴을 바꾸고 설정 여부를 확인하십시오.</para>
</listitem>
<listitem>
<para>프로그램의 색상 바꾸기를 시험하고 설정 여부를 확인하십시오.</para>
</listitem>
<listitem>
<para>돋보기를 활용할 수 있다면, 돋보기 옵션을 활용하여 글꼴, 색상, 크기를 시험하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>색상 및 대비</title>
<itemizedlist>
<listitem>
<para>흑백 인쇄기로 화면 사진을 인쇄하여 모든 정보가 나타나는지 확인하십시오.</para>
</listitem>
<listitem>
<para>흑백, 고대비 설정 상태에서 프로그램을 시험하고 모든 정보를 올바르게 보여주는지 확인하십시오.</para>
</listitem>
<listitem>
<para>최소한 세가지 이상의 색상 설정 조합과 고대비 색상 설정(흑백, 황청) 상태에서 프로그램을 시험하십시오.</para>
</listitem>
<listitem>
<para>그놈 제어 센터에서 고대비 설정을 활성화하고 프로그램이 이 설정을 소화하는지 확인하십시오.</para>
</listitem>
<listitem>
<para>다양한 테마를 시험하여 프로그램이 가능한 모든 설정에서 동작하는지 확인하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>음성</title>
<para>음성 알림을 시각으로 보여주는 프로그램의 설정 항목이 있어야합니다.</para>
<para>그놈 제어 센터의 소리 기능을 활성화하여 음성 재생이 동작하는지 시험하시고 다음 과정을 수행하십시오:</para>
<itemizedlist>
<listitem>
<para>음성 경고가 뜨는  동작을 수행해보시고 프로그램이 의도 대로 동작하는지 확인하십시오.</para>
</listitem>
<listitem>
<para>음량을 증가하거나 감소할 때 프로그램이 올바르게 동작하는지 확인하십시오.</para>
</listitem>
<listitem>
<para>경고 메시지 및 경고음이 시끄러운 환경에서 분명하기 들리는지 확인하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>애니메이션</title>
<para>애니메이션을 멈출 수 있는 설정 항목이 있는지 확인하시고 의도 대로 동작하는지 확인하십시오.</para>
<para>애니메이션을 끄십시오. 모든 정보를 여전히 올바르게 보여주는지 확인하십시오.</para>
</section>

<section>
<title>키보드 포커스</title>
<itemizedlist>
<listitem>
<para>모든 메시지를 확인하여 메시지 표시 제한 시간을 넘기기 전 사용자가 인지하는지, 메시지를 나타낼 시간이 더 필요할 때 설정할 항목이 있는지 확인하십시오.</para>
</listitem>
<listitem>
<para>응답 시간을 조절할 설정 항목을 넣었는지 확인하시고 의도 대로 동작하는지 확인하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section>
<title>문서</title>
<para>ASCII 텍스트 문서를 스크린 리더에서 읽게 시험하고, 분명하고  정확하게 읽는지, 보조 기술로 읽을 수 있는지 확인하십시오.</para>
<para>웹 브라우저 및 스크린 리터로 HTML 프로그램을 시험하시고 보조 기술로 문서에 접근할 수 있는지 확인하십시오.</para>
<para>참고: <ulink url="http://www.w3.org/TR/WAI-WEBCONTENT/">http://www.w3.org/TR/WAI-WEBCONTENT/</ulink> 링크에 웹 접근성 지침서가 있습니다.</para>
<para>문서에 다음 내용을 넣었는지 확인하십시오:</para>
<itemizedlist>
<listitem>
<para>운영체제에서 사용하는 표준 키보드 단축키 접근에 대해 프로그램의 지원 여부를 분명히 나타내는가.</para>
</listitem>
<listitem>
<para>유일 키보드 명령이 있는 경우를 나타내는가.</para>
</listitem>
<listitem>
<para>접근성 기능 동작이 유일함을 나타내는가.</para>
</listitem>
<listitem>
<para>마우스 동작을 문서화했다면 키보드를 사용한 대체 방안이 있는지 확인하십시오.</para>
</listitem>
</itemizedlist>
</section>

<section id="gad-checklist">
<title>사용자 인터페이스 확인 목록</title>
<para>이 섹션은 <link linkend="gad-ui-guidelines">사용자 인터페이스의 접근성 지원 지침서</link>에 제시한 지침의 요약 부분입니다. 여기에 제시한 확인 목록의 항목에 띄운 자세한 정보의 섹션별 안내를 참고하십시오.</para>
<para>프로그램의 편의성을 시험하려면, 목록의 각 항목을 따라야합니다. 프로그램이 각 항목의 요구사항을 만족하는지, 프로그램에 적용하지 않았는지 확인하십시오.</para>
<table frame="all" pgwide="1">
<title>일반 원리 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>GP</entry>
<entry>일반 원리</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row>
<entry>GP.1</entry>
<entry>사용자의 데이터 또는 프로그램 설정을 바꾸는 모든 동작은 도중에 멈출 수 있습니다.</entry>
</row>
<row>
<entry>GP.2</entry>
<entry>사용자가 기본 설정을 기억하지 않아도 모든 포르개렘 설정을 기본 값으로 복원할 수 있습니다.</entry>
</row>
<row>
<entry>GP.3</entry>
<entry>설치가 끝나면, 사용자가 디스크 또는 CD를 언제든 직접 넣지 않아도 프로그램을 사용할 수 있습니다.</entry>
</row>
<row><entry>GP.4</entry>
<entry>가장 자주 사용하는 기능은 메뉴 구조상 최상단에서 찾을 수 있습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>키보드 탐색 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>KN</entry>
<entry>키보드 탐색</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row>
<entry>KN.1</entry>
<entry>모든 프로그램의 기능에 대해 효율적인 키보드 접근 수단을 제공합니다.</entry>
</row>
<row>
<entry>KN.2</entry>
<entry>모든 창에 논리적인 키보드 탐색 순서를 부여합니다.</entry>
</row>
<row><entry>KN.3</entry>
<entry>확인 상자, 라디오 단추, 토글 단추에 대해 어떤 상태를 활성화할 지 컨트롤에 올바른 탭 순서를 적용합니다.</entry>
</row>
<row><entry>KN.4</entry>
<entry>프로그램별 기능에 접근할 키보드는 기존의 시스템 접근성 기능을 무력화하지 않습니다.</entry>
</row>
<row><entry>KN.5</entry>
<entry>가능할 경우 프로그램에서 처리할 키보드 처리 수단을 하나 이상 제공합니다.</entry>
</row>
<row><entry>KN.6</entry>
<entry>가능한 어디든 대체 단축키가 있습니다.</entry>
</row>
<row><entry>KN.7</entry>
<entry>주로 실행하는 키보드 동작을 다룰 때 불편함이 없습니다.</entry>
</row>
<row><entry>KN.8</entry>
<entry>프로그램은 반복적인, 동시 키 누름 동작을 활용하지 않습니다.</entry>
</row>
<row><entry>KN.9</entry>
<entry>프로그램에서는 키보드 누름과 동일한 동작을 하는 모든 마우스 기능을 제공합니다.</entry>
</row>
<row><entry>KN.10</entry>
<entry>마우스로 선택할 수 있는 어떤 텍스트 및 객체든 키보드 만으로도 선택할 수 있습니다.</entry>
</row>
<row><entry>KN.11</entry>
<entry>마우스로 크기를 조절하거나 이동할 수 있는 객체는 키보드만드로도 크기를 조절하거나 옮길 수 있습니다.</entry>
</row>
<row><entry>KN.12</entry>
<entry>프로그램에서 동작을 처리할 때 어떤 일반 탐색 기능도 활용하지 않습니다.</entry>
</row>
<row><entry>KN.13</entry>
<entry>키보드로 실행하는 모든 메뉴, 창, 풍선 도움말은 관련 대상 객체 근처에 나타냅니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>마우스 동작 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>MI</entry>
<entry>마우스 동작</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>MI.1</entry>
<entry>마우스 <mousebutton>오른쪽</mousebutton> 단추 또는 <mousebutton>가운데</mousebutton> 단추 입력에 의존하도록 처리하지 않습니다.</entry>
</row>
<row><entry>MI.2</entry>
<entry>모든 마우스 동작은 처리가 끝나기 전에 취소할 수 있습니다.</entry>
</row>
<row><entry>MI.3</entry>
<entry>끌어다 놓기 동작시 시각적 반응 효과를 제공합니다.</entry>
</row>
<row><entry>MI.4</entry>
<entry>마우스 포인터는 프로그램 컨트롤을 건너뛰거나 프로그램으로 화면 일부 영역 안에서 움직이도록 제한하지 않습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>그래픽 요소 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>GE</entry>
<entry>그래픽 요소</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>GE.1</entry>
<entry>선, 테두리, 그림자 두께 같은 그래픽 속성값을 코드에 넣지 않습니다.</entry>
</row>
<row><entry>GE.2</entry>
<entry>모든 다중 색상 그래픽 요소는 가능한 경우 흑백만으로도 나타낼 수 있습니다.</entry>
</row>
<row><entry>GE.3</entry>
<entry>모든 대화식 GUI 구성 요소는 정적 GUI 요소와 쉽게 구별할 수 있어야 합니다.</entry>
</row>
<row><entry>GE.4</entry>
<entry>중요하지 않은 그래픽 요소를 숨기는 설정 항목을 제공합니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>글꼴 및 글자 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>FT</entry>
<entry>글꼴 및 텍스트</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>FT.1</entry>
<entry>글꼴 모양새나 크기를 코드에 직접 넣지 않습니다.</entry>
</row>
<row><entry>FT.2</entry>
<entry>텍스트 뒤에 나타나는 그래픽 배경을 끄는 설정 항목을 제공합니다.</entry>
</row>
<row><entry>FT.3</entry>
<entry>모든 레이블은 컨텍스트를 벗어났을 때 알아차리 수 있도록 이름을 가집니다.</entry>
</row>
<row><entry>FT.4</entry>
<entry>동일한 창에서 레이블 이름을 두 번 이상 활용하지 않습니다.</entry>
</row>
<row><entry>FT.5</entry>
<entry>프로그램의 레이블 위치는 이곳 저곳에 정해놓습니다.</entry>
</row>
<row><entry>FT.6</entry>
<entry>다른 컨트롤을 식별하는 모든 정적 텍스트 레이블은 콜론(:)으로 끝납니다.</entry>
</row>
<row><entry>FT.7</entry>
<entry>다른 컨트롤을 식별하는 정적 텍스트 레이블은 탭 순서상 바로 앞에 위치합니다.</entry>
</row>
<row><entry>FT.8</entry>
<entry>위지윅 대체 수단을 제공합니다. 이를테면, 화면과 프린터 글꼴을 텍스트 편집기에서 다르게 지정할 수 있게 합니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>색상 및 대비 체크 리스트</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>CC</entry>
<entry>색상 및 대비</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>CC.1</entry>
<entry>프로그램 색상은 코드에 직접 넣지 않지만, 현재 데스크톱 테마 또는 프로그램 설정에 따라 나타납니다.</entry>
</row>
<row><entry>CC.2</entry>
<entry>색상은 강조 용도로만 사용하며 정보 또는 동작을 전달하는 의미만으로 활용하지 않습니다.</entry>
</row>
<row>
<entry>CC.3</entry>
<entry>이 프로그램은 모든 고대비 테마와 설정을 지원합니다.</entry>
</row>
<row><entry>CC.4</entry>
<entry>프로그램은 특정 고대비 테마 또는 설정에 의존하지 않습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>돋보기 기능 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>MG</entry>
<entry>확대/축소</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>MG.1</entry>
<entry>프로그램에서는 작업 영역 보기를 확대하는 기능을 제공합니다.</entry>
</row>
<row><entry>MG.2</entry>
<entry>프로그램에서는 작업 영역의 크기를 조절하는 설정 항목을 제공합니다.</entry>
</row>
<row><entry>MG.3</entry>
<entry>프로그램의 기능은 확대, 크기 설정을 바꿀 때 영향을 받지 않습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>오디오 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>AU</entry>
<entry>음성</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>AU.1</entry>
<entry>어떤 항목의 정보를 전달하려는 의미로만 소리를 활용하지 않습니다.</entry>
</row>
<row><entry>AU.2</entry>
<entry>모든 음성과 경고 비프음의 주파수 및 음량을 사용자가 설정할 수 있습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>애니메이션 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>AN</entry>
<entry>애니메이션</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>AN.1</entry>
<entry>번쩍이거나 깜빡이는 요소의 효과는 초당 2번 이상 55번 이하로 나타내지 않습니다.</entry>
</row>
<row><entry>AN.2</entry>
<entry>번쩍이거나 깜빡이는 효과는 화면의 좁은 영역에 한정합니다.</entry>
</row>
<row><entry>AN.3</entry>
<entry>애니메이션을 사용한다면 처음 나타나기 전에 끌 수 있는 옵션을 제공합니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>키보드 포커싱 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>KF</entry>
<entry>키보드 포커스</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>KF.1</entry>
<entry>창을 열면 주로 사용하는 컨트롤에 포커스를 맞춘 채로 시작합니다.</entry>
</row>
<row><entry>KF.2</entry>
<entry>현재 입력 포커스 위치는 언제든 분명하게 나타냅니다.</entry>
</row>
<row><entry>KF.3</entry>
<entry>입력 포커스는 항상 하나의 창에 분명하게 나타냅니다.</entry>
</row>
<row><entry>KF.4</entry>
<entry>사용자가 관련 그룹 객체의 이전 및 끝자락을 탐색할 때 적당한 음성 또는 시각 반응을 제공합니다.</entry>
</row>
<row><entry>KF.5</entry>
<entry>사용자가 잘못된 키를 눌렀을 경우 기본 음성, 시각 경고 알림을 재생합니다.</entry>
</row>
<row><entry>KF.6</entry>
<entry>사용자가 다음 과정에 할 수 있는 동작에 대한 시각 포커스에 대한 충분한 음성 정보를 제공합니다.</entry>
</row>
<row><entry>KF.7</entry>
<entry>스크린 리더 또는 점자 장치 등의 보조 기술을 활용한다면, 현재 프로그램의 위치와 시각 포커스 표시 내용을 나타냅니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>타이밍 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>TM</entry>
<entry>타이밍</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>TM.1</entry>
<entry>프로그램에는 코드에 직접 넣은 제한 시간 또는 시간 기반 기능을 넣지 않습니다.</entry>
</row>
<row><entry>TM.2</entry>
<entry>마우스 포인터 커서를 움직일 때 중요한 정보를 나타내거나 숨기는 동작을 단독으로 처리하지 않습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
<table frame="all" pgwide="1">
<title>문서 확인 목록</title>
<tgroup cols="3" align="left">
<thead>
<row>
<entry>DC</entry>
<entry>문서</entry>
<entry>통과/확인/없음</entry>
</row>
</thead>
<tbody>
<row><entry>DC.1</entry>
<entry>모든 문서에는 모든 그림과 도식에 텍스트 대체 설명이 담긴 편의 형식을 갖추고 있습니다.</entry>
</row>
<row><entry>DC.2</entry>
<entry>문서에는 프로그램의 접근성 기능을 다루는 섹션이 담겨있습니다.</entry>
</row>
</tbody>
</tgroup>
</table>
</section>

<section>
<title>GOK (그놈 화면 키보드)</title>
<note>
<para>이 페이지의 정보는 오래됐습니다. 그놈 2의 <application>gok</application>는 사실상 그놈 3의 <application><ulink url="http://wiki.gnome.org/Caribou">칼리부</ulink></application> 로 바뀌었습니다.</para>
</note>

<para><application>gok</application>로도 프로그램을 활용할 수 있어야합니다. 키보드가 아닌 <application>gok</application>로도 키 입력을 처리할 수 있어야합니다. 보통 화면 키보드로 문자 입력을 처리할 수 있는지 여부를 확인하여 프로그램과 데스크톱에서 동작하게 하는게 목표입니다.</para>
<para><application>gok</application> 프로그램은 그놈 데스크톱 모음에 실려있으므로 이미 나타나야합니다. 전체 문서는 <ulink url="http://www.gok.ca">공식 gok 사이트</ulink>를 참고하십시오.</para>
<para>프로그램에 올바른 <application>gok</application> 동작을 확인하려면 다음 단계를 따르십시오:</para>
<procedure>
<step>
<para>그놈 데스크톱에 로그인하십시오</para>
</step>
<step>
<para><application>gok</application>를 실행하십시오</para>
</step>
<step>
<para>프로그램을 시작하십시오</para>
</step>
<step>
<para>지시 장치(마우스 또는 헤드 트래커)로 프로그램과 <application>gok</application>에 입력하십시오.</para>
</step>
<step>
<para><application>gok</application>의 자동 완성 및 단어 예측 기능을 활용해보십시오.</para>
</step>
<step>
<para>실행 프로그램에 따라  <application>gok</application>에서 <guibutton>메뉴</guibutton>단추 및 <guibutton>도구 모음</guibutton>단추를 활성화 내지는 비활성화했는지 확인하십시오. 일례로, <guibutton>메뉴</guibutton>단추와 <guibutton>도구 모음</guibutton> 단추는 '글꼴 속성'에서 비활성화하지만, <application>지에디트</application> 프로그램에선 동일한 단추를 활성화합니다.</para>
</step>
<step>
<para><guibutton>작성</guibutton> 단추를 눌렀을 때 나타나는 <application>gok</application> 화면 키보드에서 선택한 프로그램에 텍스트를 입력할 수 있는지 확인하십시오. <application>지에디트</application>를 실행하고 텍스트 입력 부분을 누른 후, <application>gok</application>에서 <guibutton>작성</guibutton> 단추를 누르십시오. 화면 키보드에서 필요한 키를 선택하십시오. <application>지에디트</application> 텍스트 영역에 문자가 나타나야합니다.</para>
</step>
<step>
<para>사용자가 <guibutton>실행 아이콘</guibutton> 단추를 누르면 <application>터미널</application>, <application>웹 브라우저</application>, <application>텍스트 편집기</application> 프로그램 중 하나를 실행할 수 있는지 확인하십시오.</para>
</step>
<step>
<para>사용자가 <guibutton>활성</guibutton> 단추를 누르면, 그놈 패널, 그놈 데스크톱, 사용자 데스크톱의 실행 중인 프로그램 창 중 하나를 활성화할 수 있는지 확인하십시오.</para>
</step>
<step>
<para><guibutton>메뉴</guibutton> 단추를 누르면 현재 프로그램의 모든 메뉴를 나타내는지 확인하십시오. 메뉴 단추를 누르면 하위 메뉴와 하위 메뉴에 들어있는 메뉴 항목을 표시하는지 확인하십시오. 마지막으로, 메뉴 항목을 누르면 활성화하는지 확인하십시오. <application>도움말 탐색기</application> 프로그램을 누르고 <guibutton>메뉴</guibutton> 단추를 누르십시오. 그러면, <application>GOK</application>창에 <guibutton>파일</guibutton>, <guibutton>이동</guibutton>, <guibutton>도움말</guibutton>단추(<application>도움말 탐색기</application> 메뉴)가 나타납니다. <guibutton>파일</guibutton> 단추를 누르면 <guibutton>새 창</guibutton>과 <guibutton>창 닫기</guibutton> 단추(메뉴 항목)가 뜹니다.</para>
</step>
<step>
<para><guibutton>도구 모음</guibutton> 단추가 프로그램 도구 모음에서 사용할 수 있는 모든 단추를 표시하는지 확인하십시오. 예를 들자면 <application>도움말 탐색기</application> 프로그램을 누르고 <guibutton>도구 모음</guibutton> 단추를 누르십시오. 이제 <application>GOK</application> 창에서 <guibutton>뒤로 가기</guibutton>, <guibutton>앞으로 가기</guibutton>, <guibutton>처음</guibutton> 단추를 보여줍니다.</para>
</step>
<step>
<para><guibutton>UI 잡기</guibutton> 단추가 선택한 프로그램 창의 모든 단추 객체를 표시하는지 확인하십시오. 예를 들어, <application>GOK</application> 창에서 '글꼴 속성' 창을 열고  <guibutton>UI 잡기</guibutton> 단추를 누르십시오. <application>GOK</application> 창의 글꼴 속성 창에 <guibutton>Sans</guibutton>, <guibutton>Sans-serif</guibutton>, <guibutton>닫기</guibutton>, <guibutton>도움말</guibutton> 이름을 가진 단추가 나타나야합니다.</para>
</step>
</procedure>
</section>

<section>
<title>액서사이저</title>
<screenshot>
<mediaobject><imageobject> <imagedata fileref="figures/at-arch.png" format="PNG"/> </imageobject> <textobject> <phrase> 액서사이저와 그놈 접근성 구조 </phrase> </textobject></mediaobject>
</screenshot>

<para><application>액서사이저</application>는 그놈 데스크톱에서 활용하는 대화형 파이썬 접근성 탐색기입니다. AT-SPI로 위젯을 검사하고 제어하며, 프로그램이 보조 기술 매개에 올바른 정보를 제공하는지 확인하고 시험 프레임워크를 자동화할 수 있게 합니다. <application>액서사이저</application>에는 접근성 정보의 개별 뷰를 만들 수 있는 단순 플러그인 프레임워크가 있습니다. <application>액서사이저</application>와 <application>PyATSPI</application>(파이썬에 맞춘 AT-SPI 접근 활용 구현체)의 시험 예제를 보려면 <ulink url="http://live.gnome.org/Accessibility/PythonPoweredAccessibility">이 글</ulink>을 참고하십시오. 작자가 추천하는 최고의 참고자료를 검토하신다면 <ulink url="http://www.linuxjournal.com/article/9991">Make Your Application Accessible with Accerciser</ulink> 게시글을 살펴보십시오.</para>
<note>
<para>이전의 <application>at-poke</application> 도구는 사실상 <application>액서사이저</application>로 완전히 바뀌었습니다.</para>
</note>
</section>

</chapter>

</book>
